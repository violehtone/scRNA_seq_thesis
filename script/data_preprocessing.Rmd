---
title: "Data preprocessing"
author: "Ville Lehtonen"
date: "9/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working dir to the source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

# Data preprocessing

## Note
**In case you are running this script for the first time, please remove the eval=FALSE from the code chunks below. Otherwise, if you already have the sce objects saved locally, please continue from the chunk "shortcut-load-sce-files" to speed up the process.**

## 1. Introduction
This script is used for performing the data pre-processing of 3 scRNA-seq data sets.
One dataset is primary data and the other two are used as reference datasets.
Reference data sets:
  - De Micheli et al. (2020): GSE143435 data set
  - Dell'Orso et al. (2019): GSE126834 data set

The data sets are available in NCBI GEO:
  - https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE126834
  - https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE143435


## 2. Load packages
```{r load-packages, message=FALSE}
library(scater)
library(scran)
library(SingleCellExperiment)
library(DropletUtils)
library(Seurat)
library(dplyr)
library(docstring)
library(ggplot2)
library(edgeR)
library(biomaRt)
library(scRNAseq)
library(org.Mm.eg.db)
library(SingleR)
library(batchelor)
library(pheatmap)
library(igraph)
library(fossil)
```

## 3. Utility functions
```{r utility-functions}
firstColumnToRowNames <- function(data) {
  #' Function to manipulate data so that the first column is moved to the rownames
  rownames(data) <- data[, 1]
  data <- data[, -1]
  return(data)
}

optimize_k <- function(sce, values, assay_name) {
  #' Calculate modularities for different values of k
  #' sce = SingleCellExperiment object, values = sequence of k values (i.e. seq(5,10)), assay_name = name of the assay to be used
  dimensions <- ncol(reducedDim(sce))
  results <- list()
  
  for (i in values) {
    snng <- buildSNNGraph(sce, d = dimensions, assay.type = assay_name, k = i)
    clust <- igraph::cluster_walktrap(snng)$membership
    mod <- modularity(snng, clust)
    results[[paste(i)]] <- mod
  }
  return(results)
}

```

## 4. Load data
### 4.1 Primary data
```{r load-primary-data, eval=FALSE}
counts <- Read10X("./../data/filtered_feature_bc_matrix/")
counts <- counts[rowSums(counts) > 0, ]

cellcodes <- as.data.frame(counts@Dimnames[[2]])
colnames(cellcodes) <- "barcodes"
rownames(cellcodes) <- cellcodes$barcodes
cellcodes$libcodes <- as.factor(gsub(pattern=".+-", replacement="", cellcodes$barcodes))
samples<-c("control","cap50","cap50_r4h","cap50_r8h","cap50_r16h")
cellcodes$samples <- as.vector(samples[cellcodes$libcodes])
```

### 4.2 De Micheli et al. (2020) reference data
```{r load-deMicheli-data, eval=FALSE}
# Load GSE143437 data set (non-FACS sorted samples: d0, d5, d7)
GSE143437_raw <- read.delim("./../data/GSE143437/GSE143437_DeMicheli_MuSCatlas_rawdata.txt")
GSE143437_meta <- read.delim("./../data/GSE143437/GSE143437_DeMicheli_MuSCatlas_metadata.txt")
GSE143437_raw <- firstColumnToRowNames(GSE143437_raw)
GSE143437_meta <- firstColumnToRowNames(GSE143437_meta)
```

### 4.3 Dell'Orso et al. (2019) reference data
```{r load-dellOrso-data, eval=FALSE}
# Get the sample directory paths
samples <- c("./../data/GSE126834/homeostatic_muscs_1",
             "./../data/GSE126834/homeostatic_muscs_2",
             "./../data/GSE126834/inj_60h_muscs_1",
             "./../data/GSE126834/inj_60h_muscs_2",
             "./../data/GSE126834/primary_MB")

# Read samples separately
GSE126834_hom1 <- Read10X(data.dir = samples[1])
GSE126834_hom2 <- Read10X(data.dir = samples[2])
GSE126834_inj1 <- Read10X(data.dir = samples[3])
GSE126834_inj2 <- Read10X(data.dir = samples[4])
GSE126834_mb <- Read10X(data.dir = samples[5])

# Add unique identifier for column names of each dataset
colnames(GSE126834_hom1) <- paste(colnames(GSE126834_hom1), "hom1", sep = "_")
colnames(GSE126834_hom2) <- paste(colnames(GSE126834_hom2), "hom2", sep = "_")
colnames(GSE126834_inj1) <- paste(colnames(GSE126834_inj1), "inj1", sep = "_")
colnames(GSE126834_inj2) <- paste(colnames(GSE126834_inj2), "inj2", sep = "_")
colnames(GSE126834_mb) <- paste(colnames(GSE126834_mb), "mb", sep = "_")
```

## 5 Build sce objects
### 5.1 Primary data
```{r primary-data-build-sce, eval=FALSE}
# Create an sce object and add sample for each cell
sce <- SingleCellExperiment(assays=list(counts=counts))
colData(sce)$sample <- as.vector(cellcodes$samples)

# Save sce object
#saveRDS(sce, file = "./../saved/sce")

# Free space
remove(counts)
```

### 5.2 De Micheli et al. (2020) reference data
```{r deMicheli-build-sce, eval=FALSE}
# Create a sce object
sce.deMicheli <- SingleCellExperiment(assays = list(counts = as.matrix(GSE143437_raw)),
                                      colData = GSE143437_meta)

# Filter only relevant cell types and samples for building the MuSC trajectory
sce.deMicheli <- sce.deMicheli[, sce.deMicheli$cell_annotation %in% c('MuSCs and progenitors', 'Mature skeletal muscle')]
sce.deMicheli <- sce.deMicheli[, sce.deMicheli$sampleID != "D0_Cv3"]

# Save sce object
#saveRDS(sce.deMicheli, file = "./../saved/sce_deMicheli")

# free memory
remove(GSE143437_raw)
remove(GSE143437_meta)
```

### 5.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-build-sce, eval=FALSE}
# Create sce objects
sce_GSE126834_hom1 <- SingleCellExperiment(assays = list(counts = GSE126834_hom1))
sce_GSE126834_hom2 <- SingleCellExperiment(assays = list(counts = GSE126834_hom2))
sce_GSE126834_inj1 <- SingleCellExperiment(assays = list(counts = GSE126834_inj1))
sce_GSE126834_inj2 <- SingleCellExperiment(assays = list(counts = GSE126834_inj2))
sce_GSE126834_mb <- SingleCellExperiment(assays = list(counts = GSE126834_mb))

# Assign sample groups to the sce objects
sce_GSE126834_hom1$sample <- "homeostatic_MuSCs_rep1"
sce_GSE126834_hom2$sample <- "homeostatic_MuSCs_rep2"
sce_GSE126834_inj1$sample <- "inj_60h_MuSCs_rep1"
sce_GSE126834_inj2$sample <- "inj_60h_MuSCs_rep2"
sce_GSE126834_mb$sample <- "Primary_MB"

# Merge the samples into a single sce object (samples separated by the $sample column)
sce.dellOrso <- cbind(sce_GSE126834_hom1, sce_GSE126834_hom2,
                      sce_GSE126834_inj1, sce_GSE126834_inj2,
                      sce_GSE126834_mb,
                      deparse.level = 1)

# Save sce object
#saveRDS(sce.dellOrso, file = "./../saved/sce_dellOrso")

# free memory
remove(sce_GSE126834_hom1)
remove(sce_GSE126834_hom2)
remove(sce_GSE126834_inj1)
remove(sce_GSE126834_inj2)
remove(sce_GSE126834_mb)
remove(GSE126834_hom1)
remove(GSE126834_hom2)
remove(GSE126834_inj1)
remove(GSE126834_inj2)
remove(GSE126834_mb)
```


## Shortcut: Load sce files directly
**Note: the code chunks above for data loading and sce object creation are not executed (eval=FALSE) because the computation time is long so to speed-up things, we just load the sce files of the 3 datasets directly from the pre-saved files stored locally. In case you are running this script for the first time (and don't have the sce files ready), please ignore this code chunk and run all the chunks above.**

```{r shortcut-load-sce-files}
sce <- readRDS("./../saved/sce")
sce.deMicheli <- readRDS("./../saved/sce_deMicheli")
sce.dellOrso <- readRDS("./../saved/sce_dellOrso")
```

## 6 Quality Control (QC)
Metrics of low quality:
 - Cells with small library sizes (Library size = total sum of counts across all relevant features for each cell)
 - Cells with only few expressed genes (number of genes with non-zero counts for that cell)
 - Proportion of reads mapped to mitochondrial genome (high proportions = poor quality)

per cell quality metrics used:
  - sum = total count for each cell
  - detected = # of detected genes
  - subsets_mito_percent = % of reads mapped to mitochondrial transcripts

Outlier detection:
  - Outliers are detected based on median absolute deviation (MAD)
  - A value is considered an outlier if it is more than 3 MADs from the median

### 6.1 Primary data
```{r primary-data-qc}
# Compute per cell quality control metrics
sce <- addPerCellQC(sce,subsets=list(Mito=grep("mt-", rownames(sce))))
rowData(sce)$mito <- FALSE
rowData(sce)$mito[grep("^mt-",rownames(sce))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.control <- isOutlier(sce$sum[sce$sample=="control"], log=TRUE, type="both",nmads =4)
summary(qc.lib.control)

qc.lib.cap50 <- isOutlier(sce$sum[sce$sample=="cap50"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50)

qc.lib.cap50_r4h <- isOutlier(sce$sum[sce$sample=="cap50_r4h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r4h)

qc.lib.cap50_r8h <- isOutlier(sce$sum[sce$sample=="cap50_r8h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r8h)

qc.lib.cap50_r16h <- isOutlier(sce$sum[sce$sample=="cap50_r16h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r16h)

# Find outliers from total number of detected genes
qc.nexprs.control <- isOutlier(sce$detected[sce$sample=="control"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.control)

qc.nexprs.cap50 <- isOutlier(sce$detected[sce$sample=="cap50"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50)

qc.nexprs.cap50_r4h <- isOutlier(sce$detected[sce$sample=="cap50_r4h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r4h)

qc.nexprs.cap50_r8h <- isOutlier(sce$detected[sce$sample=="cap50_r8h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r8h)

qc.nexprs.cap50_r16h <- isOutlier(sce$detected[sce$sample=="cap50_r16h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r16h)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.control <- sce$subsets_Mito_percent[sce$sample=="control"] > 20
summary(qc.mito.control)

qc.mito.cap50 <- sce$subsets_Mito_percent[sce$sample=="cap50"] > 20
summary(qc.mito.cap50)

qc.mito.cap50_r4h <- sce$subsets_Mito_percent[sce$sample=="cap50_r4h"] > 20
summary(qc.mito.cap50_r4h)

qc.mito.cap50_r8h <- sce$subsets_Mito_percent[sce$sample=="cap50_r8h"] > 20
summary(qc.mito.cap50_r8h)

qc.mito.cap50_r16h <- sce$subsets_Mito_percent[sce$sample=="cap50_r16h"] > 20

# Check if qc metrics correlate

cdf <- colData(sce)[c("subsets_Mito_percent","sum","detected")]
cors <- cor(as.matrix(cdf))
cors

# Combine discards

discard.control <- qc.lib.control | qc.nexprs.control | qc.mito.control
discard.cap50 <- qc.lib.cap50 | qc.nexprs.cap50 | qc.mito.cap50
discard.cap50_r4h <- qc.lib.cap50_r4h | qc.nexprs.cap50_r4h | qc.mito.cap50_r4h
discard.cap50_r8h <- qc.lib.cap50_r8h | qc.nexprs.cap50_r8h | qc.mito.cap50_r8h
discard.cap50_r16h <- qc.lib.cap50_r16h | qc.nexprs.cap50_r16h | qc.mito.cap50_r16h


# Summarize the number of cells removed for each reason
discardSummary.control <- DataFrame(LibSize=sum(qc.lib.control), NExprs=sum(qc.nexprs.control),
                                    MitoProp=sum(qc.mito.control), Total=sum(discard.control))

discardSummary.cap50 <- DataFrame(LibSize=sum(qc.lib.cap50), NExprs=sum(qc.nexprs.cap50),
                                  MitoProp=sum(qc.mito.cap50), Total=sum(discard.cap50))

discardSummary.cap50_r4h <- DataFrame(LibSize=sum(qc.lib.cap50_r4h), NExprs=sum(qc.nexprs.cap50_r4h),
                                      MitoProp=sum(qc.mito.cap50_r4h), Total=sum(discard.cap50_r4h))

discardSummary.cap50_r8h <- DataFrame(LibSize=sum(qc.lib.cap50_r8h), NExprs=sum(qc.nexprs.cap50_r8h),
                                      MitoProp=sum(qc.mito.cap50_r8h), Total=sum(discard.cap50_r8h))

discardSummary.cap50_r16h <- DataFrame(LibSize=sum(qc.lib.cap50_r16h), NExprs=sum(qc.nexprs.cap50_r16h),
                                       MitoProp=sum(qc.mito.cap50_r16h), Total=sum(discard.cap50_r16h))

discardSummary.control
discardSummary.cap50
discardSummary.cap50_r4h
discardSummary.cap50_r8h
discardSummary.cap50_r16h

sce$discard <- c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)

# Plot QC metrics
gridExtra::grid.arrange(
  plotColData(sce, x="sample", y="sum",colour_by = "discard",point_size=0.3) +
    scale_y_log10() + ggtitle("Total counts") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="detected",colour_by = "discard",point_size=0.3) + 
    scale_y_log10() + ggtitle("Detected genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="subsets_Mito_percent",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent mitochondrial reads") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol=1,
  top = "Primary data: QC metrics"
)

# Filter outliers
sce.f <- sce[,sce$discard==FALSE]

# Check for cell type enrichment in the discarded pool
lost <- calculateAverage(counts(sce)[,c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)])
kept <- calculateAverage(counts(sce)[,!c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)])

library(edgeR)

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)
plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "Primary data: logFC between discarded and kept cells")
points(abundance[rowData(sce)$mito==TRUE], logFC[rowData(sce)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce)[changed]

# Save filtered sce file
#saveRDS(sce.f, file = "./../saved/sce_f")
```

### 6.2 De Micheli et al. (2020) reference data
```{r de-micheli-qc}
# Compute per cell quality control metrics
sce.deMicheli <- addPerCellQC(sce.deMicheli, subsets = list(Mito=grep("mt-", rownames(sce.deMicheli))))
rowData(sce.deMicheli)$mito <- FALSE
rowData(sce.deMicheli)$mito[grep("^mt-", rownames(sce.deMicheli))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.d0A <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0A)
qc.lib.d0B <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0B)
qc.lib.d0C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_Cv3"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0C)
qc.lib.d5A <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5A)
qc.lib.d5B <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5B)
qc.lib.d5C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5C)
qc.lib.d7C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D7_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d7C)
qc.lib.d7D <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D7_D"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d7D)

# Find outliers from total number of detected genes
qc.nexprs.d0A <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0A)
qc.nexprs.d0B <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0B)
qc.nexprs.d0C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_Cv3"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0C)
qc.nexprs.d5A <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5A)
qc.nexprs.d5B <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5B)
qc.nexprs.d5C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5C)
qc.nexprs.d7C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D7_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d7C)
qc.nexprs.d7D <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D7_D"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d7D)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.d0A <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_A"] > 20
summary(qc.mito.d0A)
qc.mito.d0B <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_B"] > 20
summary(qc.mito.d0B)
qc.mito.d0C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_Cv3"] > 20
summary(qc.mito.d0C)
qc.mito.d5A <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_A"] > 20
summary(qc.mito.d5A)
qc.mito.d5B <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_B"] > 20
summary(qc.mito.d5B)
qc.mito.d5C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_C"] > 20
summary(qc.mito.d5C)
qc.mito.d7C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D7_C"] > 20
summary(qc.mito.d7C)
qc.mito.d7D <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D7_D"] > 20
summary(qc.mito.d7D)

# Check if QC metrics correlate
cdf.deMicheli <- colData(sce.deMicheli)[c("subsets_Mito_percent","sum","detected")]
cors.deMicheli <- cor(as.matrix(cdf.deMicheli))
cors.deMicheli

# Combine discards
discard.d0A <- qc.lib.d0A | qc.nexprs.d0A | qc.mito.d0A
discard.d0B <- qc.lib.d0B | qc.nexprs.d0B | qc.mito.d0B
discard.d0C <- qc.lib.d0C | qc.nexprs.d0C | qc.mito.d0C

discard.d5A <- qc.lib.d5A | qc.nexprs.d5A | qc.mito.d5A
discard.d5B <- qc.lib.d5B | qc.nexprs.d5B | qc.mito.d5B
discard.d5C <- qc.lib.d5C | qc.nexprs.d5C | qc.mito.d5C

discard.d7C <- qc.lib.d7C | qc.nexprs.d7C | qc.mito.d7C
discard.d7D <- qc.lib.d7D | qc.nexprs.d7D | qc.mito.d7D

# Summarize the number of cells removed for each reason
discardSummary.d0A <- DataFrame(LibSize = sum(qc.lib.d0A),
                               NExprs = sum(qc.nexprs.d0A),
                               MitoProp = sum(qc.mito.d0A),
                               Total = sum(discard.d0A))
discardSummary.d0B <- DataFrame(LibSize = sum(qc.lib.d0B),
                               NExprs = sum(qc.nexprs.d0B),
                               MitoProp = sum(qc.mito.d0B),
                               Total = sum(discard.d0B))
discardSummary.d0C <- DataFrame(LibSize = sum(qc.lib.d0C),
                               NExprs = sum(qc.nexprs.d0C),
                               MitoProp = sum(qc.mito.d0C),
                               Total = sum(discard.d0C))

discardSummary.d5A <- DataFrame(LibSize = sum(qc.lib.d5A),
                               NExprs = sum(qc.nexprs.d5A),
                               MitoProp = sum(qc.mito.d5A),
                               Total = sum(discard.d5A))
discardSummary.d5B <- DataFrame(LibSize = sum(qc.lib.d5B),
                               NExprs = sum(qc.nexprs.d5B),
                               MitoProp = sum(qc.mito.d5B),
                               Total = sum(discard.d5B))
discardSummary.d5C <- DataFrame(LibSize = sum(qc.lib.d5C),
                               NExprs = sum(qc.nexprs.d5C),
                               MitoProp = sum(qc.mito.d5C),
                               Total = sum(discard.d5C))

discardSummary.d7C <- DataFrame(LibSize = sum(qc.lib.d7C),
                               NExprs = sum(qc.nexprs.d7C),
                               MitoProp = sum(qc.mito.d7C),
                               Total = sum(discard.d7C))
discardSummary.d7D <- DataFrame(LibSize = sum(qc.lib.d7D),
                               NExprs = sum(qc.nexprs.d7D),
                               MitoProp = sum(qc.mito.d7D),
                               Total = sum(discard.d7D))

discardSummary.d0A
discardSummary.d0B
discardSummary.d0C
discardSummary.d5A
discardSummary.d5B
discardSummary.d5C
discardSummary.d7C
discardSummary.d7D

all_discards <- c(discard.d0A, discard.d0B, discard.d0C, discard.d5A, discard.d5B, discard.d5C, discard.d7C, discard.d7D)
sce.deMicheli$discard <- all_discards

# Check cell types of discarded
table(sce.deMicheli[, sce.deMicheli$discard == TRUE]$cell_annotation)
table(sce.deMicheli$cell_annotation)

# Plot Quality control metrics
gridExtra::grid.arrange(
  plotColData(sce.deMicheli, x = "sampleID", y = "sum", colour_by = "discard", point_size = 0.3) +
    scale_y_log10() +
    ggtitle("Total counts") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x = "sampleID", y = "detected", colour_by = "discard", point_size = 0.3) +
    scale_y_log10() +
    ggtitle("Detected genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x = "sampleID", y = "subsets_Mito_percent", colour_by = "discard", point_size = 0.3) +
    ggtitle("Percent mitochondrial reads") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x="sampleID", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol = 1,
  top = "De Micheli et al. - QC metrics"
)

# Filter outliers
sce.deMicheli.f <- sce.deMicheli[, sce.deMicheli$discard == FALSE]

# Check for cell type enrichments in the discarded pool
lost <- calculateAverage(counts(sce.deMicheli)[, all_discards])
kept <- calculateAverage(counts(sce.deMicheli)[, !all_discards])

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)

plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "De Micheli et al.: logFC between discarded and kept cells")
points(abundance[rowData(sce.deMicheli)$mito==TRUE], logFC[rowData(sce.deMicheli)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce.deMicheli)[changed]

# Save filtered sce file
#saveRDS(sce.deMicheli.f, file = "./../saved/sce_deMicheli_f")
```

### 6.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-qc}
# Compute per cell quality control metrics
sce.dellOrso <- addPerCellQC(sce.dellOrso, subsets = list(Mito=grep("mt-", rownames(sce.dellOrso))))
rowData(sce.dellOrso)$mito <- FALSE
rowData(sce.dellOrso)$mito[grep("^mt-", rownames(sce.dellOrso))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.hom1 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom1)
qc.lib.hom2 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom2)
qc.lib.inj1 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj1)
qc.lib.inj2 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj2)
qc.lib.pmb <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "Primary_MB"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.pmb)

#Find outliers from total number of detected genes
qc.nexprs.hom1 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom1)
qc.nexprs.hom2 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom2)
qc.nexprs.inj1 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj1)
qc.nexprs.inj2 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj2)
qc.nexprs.pmb <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "Primary_MB"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.pmb)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.hom1 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"] > 20
summary(qc.mito.hom1)
qc.mito.hom2 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"] > 20
summary(qc.mito.hom2)
qc.mito.inj1 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"] > 20
summary(qc.mito.inj1)
qc.mito.inj2 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"] > 20
summary(qc.mito.inj2)
qc.mito.pmb <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "Primary_MB"] > 20
summary(qc.lib.pmb)

# Check if QC metrics correlate
cdf.dellOrso <- colData(sce.dellOrso)[c("subsets_Mito_percent","sum","detected")]
cors.dellOrso <- cor(as.matrix(cdf.dellOrso))
cors.dellOrso

# Combine discards
discard.hom1 <- qc.lib.hom1 | qc.nexprs.hom1 | qc.mito.hom1
discard.hom2 <- qc.lib.hom2 | qc.nexprs.hom2 | qc.mito.hom2
discard.inj1 <- qc.lib.inj1 | qc.nexprs.inj1 | qc.mito.inj1
discard.inj2 <- qc.lib.inj2 | qc.nexprs.inj2 | qc.mito.inj2
discard.pmb <- qc.lib.pmb | qc.nexprs.pmb | qc.mito.pmb

# Summarize the number of cells removed for each reason
discardSummary.hom1 <- DataFrame(LibSize = sum(qc.lib.hom1),
                               NExprs = sum(qc.nexprs.hom1),
                               MitoProp = sum(qc.mito.hom1),
                               Total = sum(discard.hom1))
discardSummary.hom2 <- DataFrame(LibSize = sum(qc.lib.hom2),
                                 NExprs = sum(qc.nexprs.hom2),
                                 MitoProp = sum(qc.mito.hom2),
                                 Total = sum(discard.hom2))
discardSummary.inj1 <- DataFrame(LibSize = sum(qc.lib.inj1),
                                 NExprs = sum(qc.nexprs.inj1),
                                 MitoProp = sum(qc.mito.inj1),
                                 Total = sum(discard.inj1))
discardSummary.inj2 <- DataFrame(LibSize = sum(qc.lib.inj2),
                                 NExprs = sum(qc.nexprs.inj2),
                                 MitoProp = sum(qc.mito.inj2),
                                 Total = sum(discard.inj2))
discardSummary.pmb <- DataFrame(LibSize = sum(qc.lib.pmb),
                                 NExprs = sum(qc.nexprs.pmb),
                                 MitoProp = sum(qc.mito.pmb),
                                 Total = sum(discard.pmb))

discardSummary.hom1
discardSummary.hom2
discardSummary.inj1
discardSummary.inj2
discardSummary.pmb

sce.dellOrso$discard <- c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)

# Plot QC metrics
gridExtra::grid.arrange(
  plotColData(sce.dellOrso, x="sample", y="sum",colour_by = "discard",point_size=0.3) +
    scale_y_log10() + 
    ggtitle("Total counts") + 
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="detected",colour_by = "discard",point_size=0.3) + 
    scale_y_log10() +
    ggtitle("Detected genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="subsets_Mito_percent",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent mitochondrial reads") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol=1,
  top = "Dell'Orso et al.: QC metrics"
)

# Filter outliers
sce.dellOrso.f <- sce.dellOrso[, sce.dellOrso$discard == FALSE]

# Check for cell type enrichment in the discarded pool
lost <- calculateAverage(counts(sce.dellOrso)[,c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)])
kept <- calculateAverage(counts(sce.dellOrso)[,!c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)])

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)
plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "Dell'Orso et al.: logFC between discarded and kept cells")
points(abundance[rowData(sce.dellOrso)$mito==TRUE], logFC[rowData(sce.dellOrso)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce.dellOrso)[changed]

# Save filtered sce file
#saveRDS(sce.dellOrso.f, file = "./../saved/sce_dellOrso_f")
```


## 7. Normalization
We perform normalization here to address for the systematic differences in sequence coverage between libraries.
We aim to remove these technical differences such that they don't interfere with comparisons of the expression profiles between cells.

Here we:
  - Perform scaling normalization by dividing all counts for each cell by a cell-specific scaling factor, also known as "size factor"
  - The size factor for each cell represents the estimate of the relative bias in that cell, so division of its counts by its size factor should remove that bias
  - Once size factors are computed, we use logNormCounts() to compute normalized exp. values for each cell

### 7.1 Primary data
```{r primary-data-normalization}
# Compute size factors
sce.n <- sce.f
lib.sf <- librarySizeFactors(sce.n)
summary(lib.sf)

set.seed(100)
quickie <- quickCluster(sce.n,block=sce.n$sample)
table(quickie)

sce.n <- computeSumFactors(sce.n, cluster=quickie)

deconv.sf <- sizeFactors(sce.n)

# Plot library size factor vs. deconvolution size factor
plot(lib.sf, deconv.sf, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16, main = "Primary data: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")

# Compute log-normalized expression values for each cell
sce.n <- logNormCounts(sce.n)

# Save normalized data
#saveRDS(sce.n, file = "./../saved/sce_n")

```

### 7.2 De Micheli et al. (2020) reference data
```{r deMicheli-normalization}
# Compute size factors
sce.deMicheli.n <- sce.deMicheli.f
lib.sf.deMicheli <- librarySizeFactors(sce.deMicheli.n)
summary(lib.sf.deMicheli)

set.seed(100)
clust.deMicheli <- quickCluster(sce.deMicheli.n)

sce.deMicheli.n <- computeSumFactors(sce.deMicheli.n,
                                     cluster = clust.deMicheli,
                                     min.mean = 0.1)

deconv.sf.deMicheli <- sizeFactors(sce.deMicheli.n)
summary(deconv.sf.deMicheli)

# Plot library size factors vs. deconvolution size factor
plot(lib.sf.deMicheli, deconv.sf.deMicheli, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16, main = "De Micheli et al.: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")

# Compute log-normalized expression values for each cell
sce.deMicheli.n <- logNormCounts(sce.deMicheli.n)

# Save normalized data
#saveRDS(sce.deMicheli.n, file = "./../saved/sce_deMicheli_n")
```


### 7.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-normalization}
# Compute size factors
sce.dellOrso.n <- sce.dellOrso.f
lib.sf.dellOrso <- librarySizeFactors(sce.dellOrso.n)
summary(lib.sf.dellOrso)

set.seed(100)
clust.dellOrso <- quickCluster(sce.dellOrso.n)

sce.dellOrso.n <- computeSumFactors(sce.dellOrso.n,
                                    cluster = clust.dellOrso,
                                    min.mean = 0.1)

deconv.sf.dellOrso <- sizeFactors(sce.dellOrso.n)
summary(deconv.sf.dellOrso)

# Plot library size factor vs. deconvolution size factor
plot(lib.sf.dellOrso, deconv.sf.dellOrso, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16,  main = "Dell'Orso et al.: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")

# Compute log-normalized expression values for each cell
sce.dellOrso.n <- logNormCounts(sce.dellOrso.n)

# Save normalized data
#saveRDS(sce.dellOrso.n, file = "./../saved/sce_dellOrso_n")
```


## 8. Variance modelling
The simplest approach to quantifying per-gene variation is to simply compute the variance of the log-normalized expression values (log counts)
  - We use the modelGeneVar() function to fit a trend to the variance with respect to abundance across all genes
  - Once we have quantified the per-gene variation, the next step is to select the subset of HVGs to use in downstream analyses.
  - Here we select top 10% of the genes with the largest values for relevant variance metric

### 8.1 Primary data
```{r primary-data-feature-selection}
# Model per-gene variance
dec.data <- modelGeneVar(sce.n)

# Visualizing the fit
fit1 <- metadata(dec.data)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression",
     ylab = "Variance of log-expression", main = "Primary data: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# Define highly variable genes (HVGs)
hvgs.data <- getTopHVGs(dec.data, prop = 0.1)

# save HVGS and per-gene variance
#saveRDS(hvgs.data, file = "./../saved/hvgs_data")
#saveRDS(dec.data, file = "./../saved/dec_data")
```


### 8.2 De Micheli et al. (2020) reference data
```{r deMicheli-feature-selection}
# Model per-gene variance (technical & biological variation)
dec.deMicheli <- modelGeneVar(sce.deMicheli.n)

#Visualize the fit
fit1 <- metadata(dec.deMicheli)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "De Micheli et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# Define the highly variable genes (HVGs)
hvgs.deMicheli <- getTopHVGs(dec.deMicheli, prop = 0.1)

# save HVGS and per-gene variance
#saveRDS(hvgs.deMicheli, file = "./../saved/hvgs_deMicheli")
#saveRDS(dec.deMicheli, file = "./../saved/dec_deMicheli")

```

### 8.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-feature-selection}
# Model per-gene variance (technical & biological variation)
dec.dellOrso <- modelGeneVar(sce.dellOrso.n)

#Visualize the fit
fit1 <- metadata(dec.dellOrso)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "Dell'Orso et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# Define the highly variable genes (HVGs)
hvgs.dellOrso <- getTopHVGs(dec.dellOrso, prop = 0.1)

# save HVGS and per-gene variance
#saveRDS(hvgs.dellOrso, file = "./../saved/hvgs_dellOrso")
#saveRDS(dec.dellOrso, file = "./../saved/dec_dellOrso")
```




## 9. Diagnosing batch effects
Here we inspect whether replicate samples in the Dell'Orso dataset cluster together or if they create separate clusters, in which case there would be a batch effect present in the data.

### 8.2 De Micheli et al. (2020) reference data
```{r deMicheli-batch-effects}
# full data
set.seed(123)
uncorrected.deMicheli <- runPCA(sce.deMicheli.n, subset_row = hvgs.deMicheli, BSPARAM = BiocSingular::RandomParam())
snn.gr.deMicheli <- buildSNNGraph(uncorrected.deMicheli, use.dimred = "PCA")
clusters.deMicheli <- igraph::cluster_walktrap(snn.gr.deMicheli)$membership
tab <- table(Cluster = clusters.deMicheli, Batch = uncorrected.deMicheli$sampleID)
tab

set.seed(123)
uncorrected.deMicheli <- runTSNE(uncorrected.deMicheli, dimred = "PCA")
plotTSNE(uncorrected.deMicheli, colour_by = "sampleID") + ggtitle("All samples") 

# Plot samples (d0, d5, d7 separately)
#d0
set.seed(123)
uncorrected.deMicheli.d0 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 0"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d0 <- buildSNNGraph(uncorrected.deMicheli.d0, use.dimred = "PCA")
clusters.deMicheli.d0 <- igraph::cluster_walktrap(snn.gr.deMicheli.d0)$membership
tab.d0 <- table(Cluster = clusters.deMicheli.d0, Batch = uncorrected.deMicheli.d0$sampleID)
tab.d0

set.seed(123)
uncorrected.deMicheli.d0 <- runTSNE(uncorrected.deMicheli.d0, dimred = "PCA")

#d5
set.seed(123)
uncorrected.deMicheli.d5 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 5"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d5 <- buildSNNGraph(uncorrected.deMicheli.d5, use.dimred = "PCA")
clusters.deMicheli.d5 <- igraph::cluster_walktrap(snn.gr.deMicheli.d5)$membership
tab.d5 <- table(Cluster = clusters.deMicheli.d5, Batch = uncorrected.deMicheli.d5$sampleID)
tab.d5

set.seed(123)
uncorrected.deMicheli.d5 <- runTSNE(uncorrected.deMicheli.d5, dimred = "PCA")

#d7
set.seed(123)
uncorrected.deMicheli.d7 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 7"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d7 <- buildSNNGraph(uncorrected.deMicheli.d7, use.dimred = "PCA")
clusters.deMicheli.d7 <- igraph::cluster_walktrap(snn.gr.deMicheli.d7)$membership
tab.d7 <- table(Cluster = clusters.deMicheli.d7, Batch = uncorrected.deMicheli.d7$sampleID)
tab.d7

set.seed(123)
uncorrected.deMicheli.d7 <- runTSNE(uncorrected.deMicheli.d7, dimred = "PCA")

# plots
p.d0 <- plotTSNE(uncorrected.deMicheli.d0, colour_by = "sampleID") + ggtitle("Day 0") 
p.d0b <- plotTSNE(uncorrected.deMicheli.d0, colour_by = "cell_annotation") + ggtitle("Day 0") 
p.d5 <- plotTSNE(uncorrected.deMicheli.d5, colour_by = "sampleID") + ggtitle("Day 5")
p.d5b <- plotTSNE(uncorrected.deMicheli.d5, colour_by = "cell_annotation") + ggtitle("Day 5")
p.d7 <- plotTSNE(uncorrected.deMicheli.d7, colour_by = "sampleID") + ggtitle("Day 7") 
p.d7b <- plotTSNE(uncorrected.deMicheli.d7, colour_by = "cell_annotation") + ggtitle("Day 7") 
gridExtra::grid.arrange(p.d0, p.d0b, p.d5, p.d5b, p.d7, p.d7b,
                        top = "De Micheli et al.: TSNE plots to diagnose batch effects")

```
 
**Conclusions:**

 - As can be seen from the Figure above, the clusters seem to separate mostly by the cell types
 - In the Day 7 sample, however, the samples seem to create separate clusters which cannot be explained by the differences in cell types. This was mentioned in the article as well but they decided to leave it uncorrected.


### 9.1 Dell'Orso et al. (2019) reference data
```{r dellOrso-batch-effects}
set.seed(123)
uncorrected.dellOrso <- runPCA(sce.dellOrso.n, subset_row = hvgs.dellOrso,
                                BSPARAM = BiocSingular::RandomParam())

snn.gr.dellOrso <- buildSNNGraph(uncorrected.dellOrso, use.dimred = "PCA")
clusters.dellOrso <- igraph::cluster_walktrap(snn.gr.dellOrso)$membership

tab <- table(Cluster = clusters.dellOrso, Batch = uncorrected.dellOrso$sample)
tab

set.seed(123)
uncorrected.dellOrso <- runTSNE(uncorrected.dellOrso, dimred = "PCA")
plotTSNE(uncorrected.dellOrso, colour_by = "sample") + ggtitle("Dell'Orso et al.: TSNE plot to diagnose batch effects")
```
  
**Conclusions:**
  - The replicate clusters for inj_60h_MuSCs and homeostatic_MuSCs seem to cluster together, meaning that these replicate samples contain similar gene expression data and thus no batch correction is required.


## 10. Cell cycle scoring and regression
Cell cycle scoring and regression is performed to inspect if the cell cycle phases affect the gene expression of cells and if this is the case, then this type of variability in the data is regressed out.

  - Here, we assign each cell a score, based on its expression of G2/M and S phase markers. Cells expressing neither are likely in G1 phase
  - Then, we subtract (regress out) this source of heterogeneity from the data.

We use two different methods for performing cell cycle correction. First, following a Seurat cell cycle correction (https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html) and then, following a Bioconductor approach (https://osca.bioconductor.org/cell-cycle-assignment.html)

### 10.1 Prepare cell cycle markers and transform from human to mouse genes
```{r cell-cycle-markers}
# Make mapping between human and mouse genes
ensembl.human <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl.mouse <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

mouse_to_human_genes <- getLDS(attributes = c('external_gene_name'),
                               filters = 'external_gene_name',
                               values = rownames(sce.n),
                               mart = ensembl.mouse,
                               attributesL = c('external_gene_name'),
                               martL = ensembl.human)

names(mouse_to_human_genes) <- c("mouse", "human")

# Get a list of cell cycle markers (G2/M phase and S phase markers)
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Convert cell cycle markers from human genes to mouse genes
g2m.genes.mouse <- c()
s.genes.mouse <- c()

for(g in s.genes) {
  gene <- mouse_to_human_genes[mouse_to_human_genes$human == g, ]$mouse
  if(length(gene) > 0) {
    s.genes.mouse <- append(s.genes.mouse, gene)
  }
}

for(g in g2m.genes) {
  gene <- mouse_to_human_genes[mouse_to_human_genes$human == g, ]$mouse
  if(length(gene) > 0) {
    g2m.genes.mouse <- append(g2m.genes.mouse, gene)
  }
}
```


### 10.2 Primary data (Method 1: Seurat cell cycle correction)
```{r primary-data-cc1}
# Convert sce into Seurat object
data <- as.Seurat(sce.n, counts = "counts", data = "logcounts")

# Perform Seurat normalization
data <- NormalizeData(data)

# Add normalized values from sce object to the Seurat object
data@assays$RNA@data <- logcounts(sce.n)

# Assign cell cycle scores
data <- CellCycleScoring(data, s.features = s.genes.mouse, g2m.features = g2m.genes.mouse, set.ident = TRUE)

# Visualize the distribution of cell cycle markers across
RidgePlot(data, features = c("Pcna", "Top2a", "Mcm6", "Mki67"), ncol = 2)

# Calculate the difference between the G2M and S phase scores
data$CC.Difference <- data$S.Score - data$G2M.Score

# Find variable features
data <- FindVariableFeatures(data, selection.method = "vst")

# Set HVGs from the sce object into the Seurat object's variable features
data@assays$RNA@var.features <- hvgs.data

# Create a sce object before regressing out the cell cycle effect
sce.not.cc <- as.SingleCellExperiment(data, assay = "RNA")
saveRDS(sce.not.cc, file = "./../saved/sce_not_cc")

# Regress out CC difference using the HVGs as features
data <- ScaleData(data, vars.to.regress = "CC.Difference", features = VariableFeatures(data), assay = "RNA")

# Run PCA
data <- RunPCA(data, features = c(s.genes.mouse, g2m.genes.mouse))
DimPlot(data)

data <- RunPCA(data, features = VariableFeatures(data), nfeatures.print = 10)
DimPlot(data)

# Transform back to sce object
sce.cc <- as.SingleCellExperiment(data, assay = "RNA")

# Set the CC corrected data into the sce object as an alternative experiment
cc_corrected <- SummarizedExperiment(list(counts = data@assays$RNA@scale.data))
altExp(sce.cc, "CC_corrected") <- cc_corrected

# Swap the alternative experiment into the main experiment
sce.cc <- swapAltExp(x = sce.cc,
                     name = "CC_corrected",
                     saved = "original",
                     withColData = TRUE)

# save sce object
#saveRDS(sce.cc, file = "./../saved/sce_cc")

# Plot cell cycle phases for each sample as pie charts
cc_vs_labels <- as.data.frame.matrix(table(sce.cc$Phase, sce.cc$sample))

par(mfrow=c(2,3))
pie(cc_vs_labels$control, labels = rownames(cc_vs_labels), main = "Control")
pie(cc_vs_labels$cap50, labels = rownames(cc_vs_labels), main = "Cap50")
pie(cc_vs_labels$cap50_r4h, labels = rownames(cc_vs_labels), main = "Cap50_r4h")
pie(cc_vs_labels$cap50_r8h, labels = rownames(cc_vs_labels), main = "Cap50_r8h")
pie(cc_vs_labels$cap50_r16h, labels = rownames(cc_vs_labels), main = "Cap50_r16h")

# Merge G2M and S-phase into "dividing"
sce.cc$Phase2 <- ifelse(sce.cc$Phase == "G1", "non-dividing", "dividing")

par(mfrow=c(1,1))
ggplot(data = as.data.frame(colData(sce.cc)), mapping = aes(x = factor(sample, levels = c("control", "cap50", "cap50_r4h", "cap50_r8h", "cap50_r16h")), fill = as.factor(Phase2))) +
  geom_bar(position = "dodge") +
  labs(x = "Sample", y = "Number of cells", fill = "Cell cycle phase")

# Fisher's exact test to inspect differences in cell cycle stages between groups
cont.tab <- table(sce.cc$Phase2, sce.cc$sample)
cont.tab <- cont.tab[, c("control", "cap50", "cap50_r4h", "cap50_r8h", "cap50_r16h")]

results = data.frame(t(combn(colnames(cont.tab),2)), stringsAsFactors = F)
results$p.value <- 0

for(i in 1:dim(results)[1]) {
  X1 <- results[i, 1]
  X2 <- results[i, 2]
  cont.tab.f <- cont.tab[, c(X1, X2)]
  
  # Calculate p-value for each pair 10 times
  res <- 0
  for(j in 1:100) {
    fish <- fisher.test(cont.tab.f)$p.value
    res <- sum(res, fish)
  }
  results[i, ]$p.value <- res/100
}

results$signifant <- ifelse(results$p.value < 0.05, TRUE, FALSE)

results

# Plot UMAP plots before and after regressing out the cell cycle effect
set.seed(123)
uncorrected.data <- runPCA(sce.not.cc, subset_row = hvgs.data)
uncorrected.data <- denoisePCA(uncorrected.data, technical = dec.data, subset.row = hvgs.data, assay.type = "logcounts")
dimensions <- ncol(reducedDim(uncorrected.data))
uncorrected.data <- runUMAP(uncorrected.data, dimred = "PCA", n_dimred = dimensions)

set.seed(123)
corrected.data <- runPCA(sce.cc, subset_row = hvgs.data, exprs_values = "counts")
corrected.data <- denoisePCA(corrected.data, technical = dec.data, subset.row = hvgs.data, assay.type = "counts")
dimensions.cc <- ncol(reducedDim(corrected.data))
corrected.data <- runUMAP(corrected.data, dimred = "PCA", n_dimred = dimensions.cc)

p1 <- plotReducedDim(uncorrected.data, colour_by = "Phase", dimred = "UMAP") + ggtitle("UMAP: non-corrected primary data")
p2 <- plotReducedDim(corrected.data, colour_by = "Phase", dimred = "UMAP") + ggtitle("UMAP: cc-corrected primary data")

gridExtra::grid.arrange(p1,p2)

```



### 10.3 Primary data (Method 2: Bioconductor, using reference profiles)
```{r primary-data-cc2}
# Get reference data containing mouse ESCs with known cell cycle phases
sce.ref <- BuettnerESCData()

# Find genes that are present in both datasets and are cell cycle-related.

# Retrieve cycle genes from biomaRt
cycle.anno <- biomaRt::select(org.Mm.eg.db, keytype="GOALL", keys="GO:0007049", 
                     columns="SYMBOL")[,"SYMBOL"]

# Transform reference data ensembl genes to symbols
ensembl.mouse <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

gene_list <- getBM(filters= "ensembl_gene_id",
                   attributes= c("ensembl_gene_id","external_gene_name"),
                   values= rownames(sce.ref),
                   mart= ensembl.mouse)

# --------------------------------------------------------------- #
# NOTE!
# --------------------------------------------------------------- #
# The code below is used for transforming the gene names from ensembl names to symbols. Due to the long computational time, the "cc_sce_ref_transformed" is saved as an R object and this can be used as well. In case this file wouldn't exist, the code below should be executed.

# for(i in 1:length(rownames(sce.ref))) {
#   gene <- rownames(sce.ref)[i]
#   gene_name <- gene_list[gene_list$ensembl_gene_id == gene, ]$external_gene_name
#   print(i)
#   print(gene_name)
#   if(length(gene_name) > 0) {
#     rownames(sce.ref)[i] <- gene_name
#   }
# }

# To avoid long computational time due to for loop above, read the object from file
sce.ref <- readRDS("./../saved/cc_sce_ref_transformed")
# --------------------------------------------------------------- #

# Find genes that are present in both data sets and are cell cycle related
candidates <- Reduce(intersect, 
                     list(rownames(sce.ref), rownames(sce.n), cycle.anno))

# Identify markers between cell cycle phases
sce.ref <- logNormCounts(sce.ref)
phase.stats <- pairwiseWilcox(logcounts(sce.ref),
                              sce.ref$phase,
                              direction = "up",
                              subset.row = candidates)

cycle.markers <- getTopMarkers(phase.stats[[1]],
                               phase.stats[[2]])


# Use markers to assign labels to the primary data set
assignments <- SingleR(test = sce.n,
                       ref = sce.ref,
                       labels = sce.ref$phase,
                       genes = cycle.markers)

tab <- table(assignments$labels,
             sce.n$sample)

# Plot results
tab.df <- as.data.frame.matrix(tab)
par(mfrow=c(2,3))
pie(tab.df$control, labels = rownames(tab.df), main = "Control")
pie(tab.df$cap50, labels = rownames(tab.df), main = "Cap50")
pie(tab.df$cap50_r4h, labels = rownames(tab.df), main = "Cap50_r4h")
pie(tab.df$cap50_r8h, labels = rownames(tab.df), main = "Cap50_r8h")
pie(tab.df$cap50_r16h, labels = rownames(tab.df), main = "Cap50_r16h")

# Regress out cell cycle effect
sce.cc.2 <- regressBatches(sce.n, batch = assignments$labels)

# Add metadata 'sample' information to the newly created object
sce.cc.2$sample <- sce.n$sample

# Save cell cycle corrected sce
#saveRDS(sce.cc.2, file = "./../saved/sce_cc_2")
```



## 11. Dimensionality reduction
  - PCA is performed on the log-normalized expression values by using runPCA() function
  - Methods for choosing the number of PCs to use:
      - Find elbow point in the % of variance explained by successive PCs
      - Remove PCs corresponding to technical noise

### 11.1 Primary data (no cell cycle correction)
```{r primary-data-dimension-reduction}
# Dimension reduction
set.seed(123)
sce.n <- runPCA(sce.n, subset_row = hvgs.data)
plotReducedDim(sce.n, dimred = "PCA", colour_by = "sample")

# Compute the variance explained by each PC
percent.var <- attr(reducedDim(sce.n), "percentVar")
chosen.elbow <- PCAtools::findElbowPoint(percent.var)
chosen.elbow

# Plot variance explained by PCs
par(mfrow=c(1,1))
plot(percent.var, xlab = "PC", ylab = "Variance explained (%)", main = "Primary data: Variance explained by each PC")
abline(v = chosen.elbow, col = "red")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce <- denoisePCA(sce.n, technical = dec.data, subset.row = hvgs.data)

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce))

# Save the sce object
#saveRDS(denoised.sce, file = "./../saved/denoised_sce")
```

### 11.2 Primary data (Seurat cell cycle correction)
```{r primary-data-cc1-dimension-reduction}
# Dimension reduction
set.seed(123)
sce.cc <- runPCA(x = sce.cc,
                 subset_row = hvgs.data,
                 exprs_values = "counts")

plotReducedDim(sce.cc, dimred = "PCA", colour_by = "sample")

# Compute variance explained by each PC
percent.var.cc <- attr(reducedDim(sce.cc), "percentVar")
chosen.elbow.cc <- PCAtools::findElbowPoint(percent.var.cc)
chosen.elbow.cc

# Plot variance explained by PCs
par(mfrow=c(1,1))
plot(percent.var.cc, xlab = "PC", ylab = "Variance explained (%)", main = "Primary data (Seurat cell cycle corrected): Variance explained by each PC")
abline(v = chosen.elbow.cc, col = "red")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.cc <- denoisePCA(sce.cc, technical = dec.data, subset.row = hvgs.data,
                              assay.type = "counts")

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.cc))

# Save the sce object
#saveRDS(denoised.sce.cc, file = "./../saved/denoised_sce_cc")
```

### 11.3 Primary data (Reference-based cell cycle correction)
```{r primary-data-cc2-dimension-reduction}
# Dimension reduction
set.seed(123)
sce.cc.2 <- runPCA(sce.cc.2, subset_row = hvgs.data, exprs_values = "corrected")
plotReducedDim(sce.cc.2, dimred = "PCA", colour_by = "sample")

# Compute variance explained by each PC
percent.var.cc.2 <- attr(reducedDim(sce.cc.2), "percentVar")
chosen.elbow.cc.2 <- PCAtools::findElbowPoint(percent.var.cc.2)
chosen.elbow.cc.2

# Plot variance explained by PCs
par(mfrow=c(1,1))
plot(percent.var.cc.2, xlab = "PC", ylab = "Variance explained (%)", main = "Primary data (reference-based cc correction): Variance explained by each PC")
abline(v = chosen.elbow.cc.2, col = "red")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.cc.2 <- denoisePCA(sce.cc.2, 
                                technical = dec.data,
                                subset.row = hvgs.data,
                                assay.type = "corrected")

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.cc.2))

# Save the sce object
#saveRDS(denoised.sce.cc.2, file = "./../saved/denoised_sce_cc_2")
```


### 11.4 De Micheli et al. (2020) reference data
```{r deMicheli-dimension-reduction}
# Perform dimension reduction
sce.deMicheli.n <- runPCA(sce.deMicheli.n, subset_row = hvgs.deMicheli)
plotReducedDim(sce.deMicheli.n, dimred = "PCA", colour_by = "injury")

# Compute the variance explained by each PC
percent.var.deMicheli <- attr(reducedDim(sce.deMicheli.n), "percentVar")
chosen.elbow.deMicheli <- PCAtools::findElbowPoint(percent.var.deMicheli)
chosen.elbow.deMicheli

# Plot variance explained by PCs
par(mfrow=c(1,1))
plot(percent.var.deMicheli, xlab = "PC", ylab = "Variance explained (%)", main = "De Micheli et al.: Variance explained by each PC")
abline(v=chosen.elbow.deMicheli, col = "red")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.deMicheli <- denoisePCA(sce.deMicheli.n,
                                     technical = dec.deMicheli,
                                     subset.row = hvgs.deMicheli)

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.deMicheli))

# Save sce object
#saveRDS(denoised.sce.deMicheli, file = "./../saved/denoised_sce_deMicheli")
```

### 11.5 Dell'Orso et al. (2019) reference data
```{r dellOrso-dimension-reduction}
# Perform dimension reduction
sce.dellOrso.n <- runPCA(sce.dellOrso.n, subset_row = hvgs.dellOrso)
plotReducedDim(sce.dellOrso.n, dimred = "PCA", colour_by = "sample")

# Compute the variance explained by each PC
percent.var.dellOrso <- attr(reducedDim(sce.dellOrso.n), "percentVar")
chosen.elbow.dellOrso <- PCAtools::findElbowPoint(percent.var.dellOrso)
chosen.elbow.dellOrso

# Plot variance explained by PCs
par(mfrow=c(1,1))
plot(percent.var.dellOrso, xlab = "PC", ylab = "Variance explained (%)",  main = "Dell'Orso et al.: Variance explained by each PC")
abline(v=chosen.elbow.dellOrso, col = "red")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.dellOrso <- denoisePCA(sce.dellOrso.n,
                                    technical = dec.dellOrso,
                                    subset.row = hvgs.dellOrso)

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.dellOrso))

# Save sce object
#saveRDS(denoised.sce.dellOrso, file = "./../saved/denoised_sce_dellOrso")
```



## 12. Clustering
  - Graph-based clustering (i.e. SNN, Shared nearest neighbor) is a flexible and scalable technique for clustering large scRNA-seq datasets
  - The major advantage of graph-based clustering lies in its scalability. It only requires a k-nearest neighbor search that can be done in log-linear time on average


### 12.1 Primary data (no cell cycle correction)
```{r primary-data-clustering}
# Perform clustering with k=10
dimensions <- ncol(reducedDim(denoised.sce))

denoised.sce.10 <- denoised.sce
snng.10 <- buildSNNGraph(denoised.sce.10, d = dimensions, k = 10)
clust.10 <- igraph::cluster_walktrap(snng.10)$membership
table(clust.10)
denoised.sce.10$cluster <- factor(clust.10)

set.seed(123)
reducedDim(denoised.sce.10, "force") <- igraph::layout_with_fr(snng.10)
denoised.sce.10 <- runUMAP(denoised.sce.10, dimred = "PCA", n_dimred = dimensions)
denoised.sce.10 <- runTSNE(denoised.sce.10, dimred = "PCA")

# Calculate modularity and plot cluster modularities
mod.10 <- modularity(snng.10, clust.10)
ratio.10 <- clusterModularity(snng.10, clust.10, as.ratio = TRUE)

print(paste("Modularity: ", mod.10))
pheatmap(log2(ratio.10 + 1), cluster_cols = FALSE, cluster_rows = FALSE, color=colorRampPalette(c("white", "blue"))(100), main = "k = 10")

plotReducedDim(denoised.sce.10, colour_by = "sample", dimred = "force") + ggtitle("Primary data clustering: force-directed layout (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotReducedDim(denoised.sce.10, colour_by = "sample", dimred = "PCA") + ggtitle("Primary data clustering: PCA (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotReducedDim(denoised.sce.10, colour_by = "sample", dimred = "UMAP") + ggtitle("Primary data clustering: UMAP with clusters (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotTSNE(denoised.sce.10, colour_by = "sample") + ggtitle("Primary data clustering: TSNE (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))

# Set k=10 to be used as k-value
denoised.sce <- denoised.sce.10

#saveRDS(denoised.sce, file = "./../saved/denoised_sce_clust")
```



### 12.2 Primary data (Seurat cell cycle correction)
```{r primary-data-cc-clustering}
# Perform clustering with k=10
dimensions.cc <- ncol(reducedDim(denoised.sce.cc))

denoised.sce.cc.10 <- denoised.sce.cc
snng.cc.10 <- buildSNNGraph(denoised.sce.cc.10, d = dimensions.cc, assay.type = "counts", k = 10)
clust.cc.10 <- igraph::cluster_walktrap(snng.cc.10)$membership
table(clust.cc.10)
denoised.sce.cc.10$cluster <- factor(clust.cc.10)

set.seed(123)
reducedDim(denoised.sce.cc.10, "force") <- igraph::layout_with_fr(snng.cc.10)
denoised.sce.cc.10 <- runUMAP(denoised.sce.cc.10, dimred = "PCA", n_dimred = dimensions.cc)
denoised.sce.cc.10 <- runTSNE(denoised.sce.cc.10, dimred = "PCA")

# Calculate modularity and plot cluster modularities
mod.cc.10 <- modularity(snng.cc.10, clust.cc.10)
ratio.cc.10 <- clusterModularity(snng.cc.10, clust.cc.10, as.ratio = TRUE)

print(paste("Modularity: ", mod.cc.10))
pheatmap(log2(ratio.cc.10 + 1), cluster_cols = FALSE, cluster_rows = FALSE, color=colorRampPalette(c("white", "blue"))(100), main = "k = 10")

# Plot Force-, PCA-, tSNE-, and UMAP plots
plotReducedDim(denoised.sce.cc.10, colour_by = "sample", dimred = "force") + ggtitle("Primary data (cc corrected) clustering: force-directed layout (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotReducedDim(denoised.sce.cc.10, colour_by = "sample", dimred = "PCA") + ggtitle("Primary data (cc corrected) clustering: PCA (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotReducedDim(denoised.sce.cc.10, colour_by = "sample", dimred = "UMAP") + ggtitle("Primary data (cc corrected) clustering: UMAP with clusters (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))
plotTSNE(denoised.sce.cc.10, colour_by = "sample") + ggtitle("Primary data (cc corrected) clustering: TSNE (k=10)") + theme(plot.title = element_text(size = 16, face = "bold"))

# Set k=10 to be used as k-value
denoised.sce.cc <- denoised.sce.cc.10

#saveRDS(denoised.sce.cc, file = "./../saved/denoised_sce_cc_clust")
```

### 12.3 Primary data: Subclustering and marker gene detection
#### 12.3.1 Subclustering

```{r subclustering}
# Inspect clusters in each sample
table(denoised.sce$sample, denoised.sce$cluster)
table(denoised.sce.cc$sample, denoised.sce.cc$cluster)

# Perform subclustering
subclust <- quickSubCluster(denoised.sce, groups = denoised.sce$sample, assay.type = "logcounts", normalize = FALSE)
subclust.cc <- quickSubCluster(denoised.sce.cc, groups = denoised.sce.cc$sample, assay.type = "counts", normalize = FALSE)

# Plot sublusters
p.sub.control <- plotReducedDim(subclust[["control"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data, Control sample - UMAP plot: subclusters")
p.sub.control.cc <- plotReducedDim(subclust.cc[["control"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data (cc corrected), Control sample - UMAP plot: subclusters")

p.sub.cap50 <- plotReducedDim(subclust[["cap50"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data, Cap50 sample - UMAP plot: subclusters")
p.sub.cap50.cc <- plotReducedDim(subclust.cc[["cap50"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data (cc corrected), Cap50 sample - UMAP plot: subclusters")

p.sub.cap50r4h <- plotReducedDim(subclust[["cap50_r4h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data, R4H sample - UMAP plot: subclusters")
p.sub.cap50r4h.cc <- plotReducedDim(subclust.cc[["cap50_r4h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data (cc corrected), R4H sample - UMAP plot: subclusters")

p.sub.cap50r8h <- plotReducedDim(subclust[["cap50_r8h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data, R8H sample - UMAP plot: subclusters")
p.sub.cap50r8h.cc <- plotReducedDim(subclust.cc[["cap50_r8h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data (cc corrected), R8H sample - UMAP plot: subclusters")

p.sub.cap50r16h <- plotReducedDim(subclust[["cap50_r16h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data, R16H sample - UMAP plot: subclusters")
p.sub.cap50r16h.cc <- plotReducedDim(subclust.cc[["cap50_r16h"]], colour_by = "subcluster", dimred = "UMAP") + ggtitle("Primary data (cc corrected), R16H sample - UMAP plot: subclusters")



gridExtra::grid.arrange(p.sub.control, p.sub.control.cc, ncol = 2)
gridExtra::grid.arrange(p.sub.cap50, p.sub.cap50.cc, ncol = 2)
gridExtra::grid.arrange(p.sub.cap50r4h, p.sub.cap50r4h.cc, ncol = 2)
gridExtra::grid.arrange(p.sub.cap50r8h, p.sub.cap50r8h.cc, ncol = 2)
gridExtra::grid.arrange(p.sub.cap50r16h, p.sub.cap50r16h.cc, ncol = 2)


```

#### 12.3.2 Marker gene detection
**This code chunk is not evaluated (as it would produce quite a few plots) but it can be run if one wants to see the marker genes for each sub-cluster** 
```{r marker-gene-detection, eval=FALSE}
# Find marker genes for Control sample
markers.control <- findMarkers(subclust[["control"]], groups = subclust[["control"]]$subcluster, assay.type = "logcounts", pval.type = "any", lfc = 1)
markers.control.cc <- findMarkers(subclust[["control"]], groups = subclust[["control"]]$subcluster, assay.type = "counts", pval.type = "any", lfc = 1)

Plot marker genes
for(i in 1:length(markers.control)) {
  print(i)
  chosen <- markers.control[[i]][c("Tnnt1", "Tnnt2", "Tnnt3", "Myog", "Tpm1", "Tpm2"), ]
  logFCs <- getMarkerEffects(chosen)
  pheatmap(logFCs, breaks=seq(-5, 5, length.out=101), main = paste("Control Subcluster:", i))
}

for(i in 1:length(markers.control.cc)) {
  print(i)
  chosen <- markers.control.cc[[i]][c("Tnnt1", "Tnnt2", "Tnnt3", "Myog", "Tpm1", "Tpm2"), ]
  logFCs <- getMarkerEffects(chosen)
  pheatmap(logFCs, breaks=seq(-5, 5, length.out=101), main = paste("Control Subcluster:", i))
}

```

#### 12.3.3 Clustering comparison between non-corrected and cc-corrected primary data
```{r}
# Plot a heatmap of the differences in clustering between original data and cc-corrected data
tab <- table(clust.10, clust.cc.10)
pheatmap(log10(tab+10), main = "Original data vs. CC corrected (k=10)", color=viridis::viridis(100))

# Calculate adjusted Rand index
ari <- adj.rand.index(clust.10, clust.cc.10)
print(paste("Adjusted Rand Index: ", ari))

# Calculate ari with k=50
dimensions <- ncol(reducedDim(denoised.sce))
denoised.sce.50 <- denoised.sce
snng.50 <- buildSNNGraph(denoised.sce.50, d = dimensions, k = 50)
clust.50 <- igraph::cluster_walktrap(snng.50)$membership

dimensions.cc <- ncol(reducedDim(denoised.sce.cc))
denoised.sce.cc.50 <- denoised.sce.cc
snng.cc.50 <- buildSNNGraph(denoised.sce.cc.50, d = dimensions.cc, assay.type = "counts", k = 50)
clust.cc.50 <- igraph::cluster_walktrap(snng.cc.50)$membership

tab <- table(clust.50, clust.cc.50)
pheatmap(log10(tab+10), main = "Original data vs. CC corrected (k=50)", color=viridis::viridis(100))
ari50 <- adj.rand.index(clust.50, clust.cc.50)
print(paste("Adjusted Rand Index: ", ari50))

```
**Conclusions:**
 - The adjusted rand index (ARI) increases when the k-parameter is increased (from ~0.38 to ~0.67)
 - Nevertheless, the clustering seem to differ between the cell-cycle corrected and non-corrected data sets




### 12.3 Primary data (Reference-based cell cycle correction)
```{r primary-data-cc2-clustering}
# Perform clustering
dimensions.cc.2 <- ncol(reducedDim(denoised.sce.cc.2))
snng.cc.2 <- buildSNNGraph(denoised.sce.cc.2, d = dimensions.cc.2, assay.type = "corrected")
clust.cc.2 <- igraph::cluster_walktrap(snng.cc.2)$membership
denoised.sce.cc.2$cluster <- factor(clust.cc.2)

set.seed(123)
reducedDim(denoised.sce.cc.2, "force") <- igraph::layout_with_fr(snng.cc.2)
table(clust.cc.2)

# Plot results
plotReducedDim(denoised.sce.cc.2, colour_by = "sample", dimred = "force") + ggtitle("Primary data clustering (refernce-based cc correction): force-directed layout")
plotReducedDim(denoised.sce.cc.2, colour_by = "sample", dimred = "PCA")+ ggtitle("Primary data clustering (refernce-based cc correction): PCA")

denoised.sce.cc.2 <- runUMAP(denoised.sce.cc.2, dimred = "PCA", n_dimred = dimensions.cc.2)
plotReducedDim(denoised.sce.cc.2, colour_by = "sample", dimred = "UMAP") + ggtitle("Primary data clustering (refernce-based cc correction): UMAP")
plotReducedDim(denoised.sce.cc.2, colour_by = "cluster", dimred = "UMAP") + ggtitle("Primary data clustering (refernce-based cc correction): UMAP with clusters")

denoised.sce.cc.2 <- runTSNE(denoised.sce.cc.2, dimred = "PCA")
plotTSNE(denoised.sce.cc.2, colour_by = "sample") + ggtitle("Primary data clustering (refernce-based cc correction): TSNE")

#saveRDS(denoised.sce.cc, file = "./../saved/denoised_sce_cc_2_clust")
```

### 12.4 De Micheli et al. (2020) reference data
```{r deMicheli-clustering}
# Perform clustering
dimensions.deMicheli <- ncol(reducedDim(denoised.sce.deMicheli))
snng.deMicheli <- buildSNNGraph(denoised.sce.deMicheli, d = dimensions.deMicheli)
clust.deMicheli <- igraph::cluster_walktrap(snng.deMicheli)$membership
denoised.sce.deMicheli$cluster <- factor(clust.deMicheli)

set.seed(123)
reducedDim(denoised.sce.deMicheli, "force") <- igraph::layout_with_fr(snng.deMicheli)
table(clust.deMicheli)

# Plot results
plotReducedDim(denoised.sce.deMicheli, colour_by = "injury", dimred = "force") + ggtitle("De Micheli et al.: force-directed layout")
plotReducedDim(denoised.sce.deMicheli, colour_by = "injury", dimred = "PCA") + ggtitle("De Micheli et al.: PCA")

denoised.sce.deMicheli <- runUMAP(denoised.sce.deMicheli, dimred = "PCA", n_dimred = dimensions.deMicheli)
plotReducedDim(denoised.sce.deMicheli, colour_by = "injury", dimred = "UMAP") + ggtitle("De Micheli et al.: UMAP")

denoised.sce.deMicheli <- runTSNE(denoised.sce.deMicheli, dimred = "PCA")
plotTSNE(denoised.sce.deMicheli, colour_by = "injury") + ggtitle("De Micheli et al.: TSNE")

#saveRDS(denoised.sce.deMicheli, file = "./../saved/denoised_sce_deMicheli_clust")
```


### 12.5 Dell'Orso et al. (2019) reference data
```{r dellOrso-clustering}
# Perform clustering
dimensions.dellOrso <- ncol(reducedDim(denoised.sce.dellOrso))
snng.dellOrso <- buildSNNGraph(denoised.sce.dellOrso, d = dimensions.dellOrso)
clust.dellOrso <- igraph::cluster_walktrap(snng.dellOrso)$membership
denoised.sce.dellOrso$cluster <- factor(clust.dellOrso)

set.seed(123)
reducedDim(denoised.sce.dellOrso, "force") <- igraph::layout_with_fr(snng.dellOrso)
table(clust.dellOrso)

# Plot results
plotReducedDim(denoised.sce.dellOrso, colour_by = "sample", dimred = "force") + ggtitle("Dell'Orso et al.: force-directed layout")
plotReducedDim(denoised.sce.dellOrso, colour_by = "sample", dimred = "PCA") + ggtitle("Dell'Orso et al.: PCA")

denoised.sce.dellOrso <- runUMAP(denoised.sce.dellOrso, dimred = "PCA", n_dimred = dimensions.dellOrso)
plotReducedDim(denoised.sce.dellOrso, colour_by = "sample", dimred = "UMAP") + ggtitle("Dell'Orso et al.: UMAP")

denoised.sce.dellOrso <- runTSNE(denoised.sce.dellOrso, dimred = "PCA")
plotTSNE(denoised.sce.dellOrso, colour_by = "sample") + ggtitle("Dell'Orso et al.: TSNE")

#saveRDS(denoised.sce.dellOrso, file = "./../saved/denoised_sce_dellOrso_clust")
```


### Extra: Create Cerebro files (.crb)
```{r cerebro-files, eval=FALSE}
denoised.sce.clust <- readRDS("./../saved/denoised_sce_clust")
denoised.sce.cc.clust <- readRDS("./../saved/denoised_sce_cc_clust")
logcounts(denoised.sce.cc.clust) <- counts(denoised.sce.cc.clust)

sce.seurat <- as.Seurat(denoised.sce.clust)
sce.cc.seurat <- as.Seurat(denoised.sce.cc.clust)

exportFromSeurat(sce.seurat, file = "./../saved/primary_data.crb", experiment_name = "Primary data (no correction)", organism = "mm",
                 column_nUMI = "sum", column_nGene = "detected", column_cluster = "cluster", column_sample = "sample")

exportFromSeurat(sce.cc.seurat, file = "./../saved/primary_data_cc_corrected.crb", experiment_name = "Primary data (cell cycle corrected)", organism = "mm",
                 column_nUMI = "sum", column_nGene = "detected", column_cluster = "cluster", column_sample = "sample", column_cell_cycle_seurat = "Phase")

```


