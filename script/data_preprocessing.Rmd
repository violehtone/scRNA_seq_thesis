---
title: "Data preprocessing"
author: "Ville Lehtonen"
date: "9/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working dir to the source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

# Data preprocessing

## Note
**In case you are running this script for the first time, please remove the eval=FALSE from the code chunks below. Otherwise, if you already have the sce objects saved locally, please continue from the chunk "shortcut-load-sce-files" to speed up the process.**

## 1. Introduction
This script is used for performing the data pre-processing of 3 scRNA-seq data sets.
One dataset is primary data and the other two are used as reference datasets.
Reference data sets:
  - De Micheli et al. (2020): GSE143437 data set
  - Dell'Orso et al. (2019): GSE126834 data set

The data sets are available in NCBI GEO:
  - https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE126834
  - https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE143437


## 2. Load packages
```{r load-packages, message=FALSE}
library(scater)
library(scran)
library(SingleCellExperiment)
library(Seurat)
library(dplyr)
library(ggplot2)
library(edgeR)
library(biomaRt)
library(scRNAseq)
library(SingleR)
library(batchelor)
library(igraph)
```

## 3. Utility functions
```{r utility-functions}
firstColumnToRowNames <- function(data) {
  # Function to manipulate data so that the first column is moved to the rownames
  rownames(data) <- data[, 1]
  data <- data[, -1]
  return(data)
}

```

## 4. Load data
### 4.1 Primary data
```{r load-primary-data, eval=FALSE}
counts <- Read10X("./../data/filtered_feature_bc_matrix/")
counts <- counts[rowSums(counts) > 0, ]

cellcodes <- as.data.frame(counts@Dimnames[[2]])
colnames(cellcodes) <- "barcodes"
rownames(cellcodes) <- cellcodes$barcodes
cellcodes$libcodes <- as.factor(gsub(pattern=".+-", replacement="", cellcodes$barcodes))
samples<-c("control","cap50","cap50_r4h","cap50_r8h","cap50_r16h")
cellcodes$samples <- as.vector(samples[cellcodes$libcodes])
```

### 4.2 De Micheli et al. (2020) reference data
```{r load-deMicheli-data, eval=FALSE}
# Load GSE143437 data set (non-FACS sorted samples: d0, d5, d7)
GSE143437_raw <- read.delim("./../data/GSE143437/GSE143437_DeMicheli_MuSCatlas_rawdata.txt")
GSE143437_meta <- read.delim("./../data/GSE143437/GSE143437_DeMicheli_MuSCatlas_metadata.txt")
GSE143437_raw <- firstColumnToRowNames(GSE143437_raw)
GSE143437_meta <- firstColumnToRowNames(GSE143437_meta)
```

### 4.3 Dell'Orso et al. (2019) reference data
```{r load-dellOrso-data, eval=FALSE}
# Get the sample directory paths
samples <- c("./../data/GSE126834/homeostatic_muscs_1",
             "./../data/GSE126834/homeostatic_muscs_2",
             "./../data/GSE126834/inj_60h_muscs_1",
             "./../data/GSE126834/inj_60h_muscs_2",
             "./../data/GSE126834/primary_MB")

# Read samples separately
GSE126834_hom1 <- Read10X(data.dir = samples[1])
GSE126834_hom2 <- Read10X(data.dir = samples[2])
GSE126834_inj1 <- Read10X(data.dir = samples[3])
GSE126834_inj2 <- Read10X(data.dir = samples[4])
GSE126834_mb <- Read10X(data.dir = samples[5])

# Add unique identifier for column names of each dataset
colnames(GSE126834_hom1) <- paste(colnames(GSE126834_hom1), "hom1", sep = "_")
colnames(GSE126834_hom2) <- paste(colnames(GSE126834_hom2), "hom2", sep = "_")
colnames(GSE126834_inj1) <- paste(colnames(GSE126834_inj1), "inj1", sep = "_")
colnames(GSE126834_inj2) <- paste(colnames(GSE126834_inj2), "inj2", sep = "_")
colnames(GSE126834_mb) <- paste(colnames(GSE126834_mb), "mb", sep = "_")
```

## 5 Build sce objects
### 5.1 Primary data
```{r primary-data-build-sce, eval=FALSE}
# Create an sce object and add sample for each cell
sce <- SingleCellExperiment(assays=list(counts=counts))
colData(sce)$sample <- as.vector(cellcodes$samples)

# Save sce object
#saveRDS(sce, file = "./../saved/R_objects/sce")

# Free space
remove(counts)
```

### 5.2 De Micheli et al. (2020) reference data
```{r deMicheli-build-sce, eval=FALSE}
# Create a sce object
sce.deMicheli <- SingleCellExperiment(assays = list(counts = as.matrix(GSE143437_raw)),
                                      colData = GSE143437_meta)

# Filter only relevant cell types and samples for building the MuSC trajectory
sce.deMicheli <- sce.deMicheli[, sce.deMicheli$cell_annotation %in% c('MuSCs and progenitors', 'Mature skeletal muscle')]
sce.deMicheli <- sce.deMicheli[, sce.deMicheli$sampleID != "D0_Cv3"]

# Save sce object
#saveRDS(sce.deMicheli, file = "./../saved/R_objects/sce_deMicheli")

# free memory
remove(GSE143437_raw)
remove(GSE143437_meta)
```

### 5.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-build-sce, eval=FALSE}
# Create sce objects
sce_GSE126834_hom1 <- SingleCellExperiment(assays = list(counts = GSE126834_hom1))
sce_GSE126834_hom2 <- SingleCellExperiment(assays = list(counts = GSE126834_hom2))
sce_GSE126834_inj1 <- SingleCellExperiment(assays = list(counts = GSE126834_inj1))
sce_GSE126834_inj2 <- SingleCellExperiment(assays = list(counts = GSE126834_inj2))
sce_GSE126834_mb <- SingleCellExperiment(assays = list(counts = GSE126834_mb))

# Assign sample groups to the sce objects
sce_GSE126834_hom1$sample <- "homeostatic_MuSCs_rep1"
sce_GSE126834_hom2$sample <- "homeostatic_MuSCs_rep2"
sce_GSE126834_inj1$sample <- "inj_60h_MuSCs_rep1"
sce_GSE126834_inj2$sample <- "inj_60h_MuSCs_rep2"
sce_GSE126834_mb$sample <- "Primary_MB"

# Merge the samples into a single sce object (samples separated by the $sample column)
sce.dellOrso <- cbind(sce_GSE126834_hom1, sce_GSE126834_hom2,
                      sce_GSE126834_inj1, sce_GSE126834_inj2,
                      sce_GSE126834_mb,
                      deparse.level = 1)

# Save sce object
#saveRDS(sce.dellOrso, file = "./../saved/R_objects/sce_dellOrso")

# free memory
remove(sce_GSE126834_hom1)
remove(sce_GSE126834_hom2)
remove(sce_GSE126834_inj1)
remove(sce_GSE126834_inj2)
remove(sce_GSE126834_mb)
remove(GSE126834_hom1)
remove(GSE126834_hom2)
remove(GSE126834_inj1)
remove(GSE126834_inj2)
remove(GSE126834_mb)
```


## Shortcut: Load sce files directly
**Note: the code chunks above for data loading and sce object creation are not executed (eval=FALSE) because the computation time is long so to speed-up things, we just load the sce files of the 3 datasets directly from the pre-saved files stored locally. In case you are running this script for the first time (and don't have the sce files ready), please ignore this code chunk and run all the chunks above.**

```{r shortcut-load-sce-files}
# Raw sce objects
sce <- readRDS("./../saved/R_objects/sce")
sce.deMicheli <- readRDS("./../saved/R_objects/sce_deMicheli")
sce.dellOrso <- readRDS("./../saved/R_objects/sce_dellOrso")
```

## 6 Quality Control (QC)
Metrics of low quality:
 - Cells with small library sizes (Library size = total sum of counts across all relevant features for each cell)
 - Cells with only few expressed genes (number of genes with non-zero counts for that cell)
 - Proportion of reads mapped to mitochondrial genome (high proportions = poor quality)

per cell quality metrics used:
  - sum = total count for each cell
  - detected = # of detected genes
  - subsets_mito_percent = % of reads mapped to mitochondrial transcripts

Outlier detection:
  - Outliers are detected based on median absolute deviation (MAD)
  - A value is considered an outlier if it is more than 3 MADs from the median

**load qc sce files**
```{r shortcut-load-qc-sce-files}
# QC sce objects
sce.f <- readRDS("./../saved/R_objects/sce_f")
sce.deMicheli.f <- readRDS("./../saved/R_objects/sce_deMicheli_f")
sce.dellOrso.f <- readRDS("./../saved/R_objects/sce_dellOrso_f")
```


### 6.1 Primary data
```{r primary-data-qc}
# Compute per cell quality control metrics
sce <- addPerCellQC(sce,subsets=list(Mito=grep("mt-", rownames(sce))))
rowData(sce)$mito <- FALSE
rowData(sce)$mito[grep("^mt-",rownames(sce))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.control <- isOutlier(sce$sum[sce$sample=="control"], log=TRUE, type="both",nmads =4)
summary(qc.lib.control)

qc.lib.cap50 <- isOutlier(sce$sum[sce$sample=="cap50"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50)

qc.lib.cap50_r4h <- isOutlier(sce$sum[sce$sample=="cap50_r4h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r4h)

qc.lib.cap50_r8h <- isOutlier(sce$sum[sce$sample=="cap50_r8h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r8h)

qc.lib.cap50_r16h <- isOutlier(sce$sum[sce$sample=="cap50_r16h"], log=TRUE, type="both",nmads =4)
summary(qc.lib.cap50_r16h)

# Find outliers from total number of detected genes
qc.nexprs.control <- isOutlier(sce$detected[sce$sample=="control"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.control)

qc.nexprs.cap50 <- isOutlier(sce$detected[sce$sample=="cap50"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50)

qc.nexprs.cap50_r4h <- isOutlier(sce$detected[sce$sample=="cap50_r4h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r4h)

qc.nexprs.cap50_r8h <- isOutlier(sce$detected[sce$sample=="cap50_r8h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r8h)

qc.nexprs.cap50_r16h <- isOutlier(sce$detected[sce$sample=="cap50_r16h"], log=TRUE, type="both",nmads =4)
summary(qc.nexprs.cap50_r16h)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.control <- sce$subsets_Mito_percent[sce$sample=="control"] > 20
summary(qc.mito.control)

qc.mito.cap50 <- sce$subsets_Mito_percent[sce$sample=="cap50"] > 20
summary(qc.mito.cap50)

qc.mito.cap50_r4h <- sce$subsets_Mito_percent[sce$sample=="cap50_r4h"] > 20
summary(qc.mito.cap50_r4h)

qc.mito.cap50_r8h <- sce$subsets_Mito_percent[sce$sample=="cap50_r8h"] > 20
summary(qc.mito.cap50_r8h)

qc.mito.cap50_r16h <- sce$subsets_Mito_percent[sce$sample=="cap50_r16h"] > 20

# Check if qc metrics correlate

cdf <- colData(sce)[c("subsets_Mito_percent","sum","detected")]
cors <- cor(as.matrix(cdf))
cors

# Combine discards
discard.control <- qc.lib.control | qc.nexprs.control | qc.mito.control
discard.cap50 <- qc.lib.cap50 | qc.nexprs.cap50 | qc.mito.cap50
discard.cap50_r4h <- qc.lib.cap50_r4h | qc.nexprs.cap50_r4h | qc.mito.cap50_r4h
discard.cap50_r8h <- qc.lib.cap50_r8h | qc.nexprs.cap50_r8h | qc.mito.cap50_r8h
discard.cap50_r16h <- qc.lib.cap50_r16h | qc.nexprs.cap50_r16h | qc.mito.cap50_r16h


# Summarize the number of cells removed for each reason
discardSummary.control <- DataFrame(LibSize=sum(qc.lib.control), NExprs=sum(qc.nexprs.control),
                                    MitoProp=sum(qc.mito.control), Total=sum(discard.control))

discardSummary.cap50 <- DataFrame(LibSize=sum(qc.lib.cap50), NExprs=sum(qc.nexprs.cap50),
                                  MitoProp=sum(qc.mito.cap50), Total=sum(discard.cap50))

discardSummary.cap50_r4h <- DataFrame(LibSize=sum(qc.lib.cap50_r4h), NExprs=sum(qc.nexprs.cap50_r4h),
                                      MitoProp=sum(qc.mito.cap50_r4h), Total=sum(discard.cap50_r4h))

discardSummary.cap50_r8h <- DataFrame(LibSize=sum(qc.lib.cap50_r8h), NExprs=sum(qc.nexprs.cap50_r8h),
                                      MitoProp=sum(qc.mito.cap50_r8h), Total=sum(discard.cap50_r8h))

discardSummary.cap50_r16h <- DataFrame(LibSize=sum(qc.lib.cap50_r16h), NExprs=sum(qc.nexprs.cap50_r16h),
                                       MitoProp=sum(qc.mito.cap50_r16h), Total=sum(discard.cap50_r16h))

discardSummary.control
discardSummary.cap50
discardSummary.cap50_r4h
discardSummary.cap50_r8h
discardSummary.cap50_r16h

sce$discard <- c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)

# Filter outliers
sce.f <- sce[,sce$discard==FALSE]

# Save filtered sce file
#saveRDS(sce.f, file = "./../saved/R_objects/sce_f")
```

**Plot QC figures**
```{r primary-qc-figures}
sce$discard <- c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)

# Plot QC metrics
gridExtra::grid.arrange(
  plotColData(sce, x="sample", y="sum",colour_by = "discard",point_size=0.3) +
    scale_y_log10() + ggtitle("Total counts") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="detected",colour_by = "discard",point_size=0.3) + 
    scale_y_log10() + ggtitle("Detected genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="subsets_Mito_percent",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent mitochondrial reads") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce, x="sample", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol=1,
  top = "Primary data: QC metrics"
)

# Check for cell type enrichment in the discarded pool
lost <- calculateAverage(counts(sce)[,c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)])
kept <- calculateAverage(counts(sce)[,!c(discard.control,discard.cap50,discard.cap50_r4h,discard.cap50_r8h,discard.cap50_r16h)])

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)
plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "Primary data: logFC between discarded and kept cells")
points(abundance[rowData(sce)$mito==TRUE], logFC[rowData(sce)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce)[changed]
```



### 6.2 De Micheli et al. (2020) reference data
```{r de-micheli-qc}
# Compute per cell quality control metrics
sce.deMicheli <- addPerCellQC(sce.deMicheli, subsets = list(Mito=grep("mt-", rownames(sce.deMicheli))))
rowData(sce.deMicheli)$mito <- FALSE
rowData(sce.deMicheli)$mito[grep("^mt-", rownames(sce.deMicheli))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.d0A <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0A)
qc.lib.d0B <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0B)
qc.lib.d0C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D0_Cv3"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d0C)
qc.lib.d5A <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5A)
qc.lib.d5B <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5B)
qc.lib.d5C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D5_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d5C)
qc.lib.d7C <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D7_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d7C)
qc.lib.d7D <- isOutlier(sce.deMicheli$sum[sce.deMicheli$sampleID == "D7_D"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.d7D)

# Find outliers from total number of detected genes
qc.nexprs.d0A <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0A)
qc.nexprs.d0B <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0B)
qc.nexprs.d0C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D0_Cv3"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d0C)
qc.nexprs.d5A <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_A"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5A)
qc.nexprs.d5B <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_B"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5B)
qc.nexprs.d5C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D5_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d5C)
qc.nexprs.d7C <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D7_C"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d7C)
qc.nexprs.d7D <- isOutlier(sce.deMicheli$detected[sce.deMicheli$sampleID == "D7_D"], log = TRUE, type = "both", nmads = 3)
summary(qc.nexprs.d7D)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.d0A <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_A"] > 20
summary(qc.mito.d0A)
qc.mito.d0B <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_B"] > 20
summary(qc.mito.d0B)
qc.mito.d0C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D0_Cv3"] > 20
summary(qc.mito.d0C)
qc.mito.d5A <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_A"] > 20
summary(qc.mito.d5A)
qc.mito.d5B <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_B"] > 20
summary(qc.mito.d5B)
qc.mito.d5C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D5_C"] > 20
summary(qc.mito.d5C)
qc.mito.d7C <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D7_C"] > 20
summary(qc.mito.d7C)
qc.mito.d7D <- sce.deMicheli$subsets_Mito_percent[sce.deMicheli$sampleID == "D7_D"] > 20
summary(qc.mito.d7D)

# Check if QC metrics correlate
cdf.deMicheli <- colData(sce.deMicheli)[c("subsets_Mito_percent","sum","detected")]
cors.deMicheli <- cor(as.matrix(cdf.deMicheli))
cors.deMicheli

# Combine discards
discard.d0A <- qc.lib.d0A | qc.nexprs.d0A | qc.mito.d0A
discard.d0B <- qc.lib.d0B | qc.nexprs.d0B | qc.mito.d0B
discard.d0C <- qc.lib.d0C | qc.nexprs.d0C | qc.mito.d0C

discard.d5A <- qc.lib.d5A | qc.nexprs.d5A | qc.mito.d5A
discard.d5B <- qc.lib.d5B | qc.nexprs.d5B | qc.mito.d5B
discard.d5C <- qc.lib.d5C | qc.nexprs.d5C | qc.mito.d5C

discard.d7C <- qc.lib.d7C | qc.nexprs.d7C | qc.mito.d7C
discard.d7D <- qc.lib.d7D | qc.nexprs.d7D | qc.mito.d7D

# Summarize the number of cells removed for each reason
discardSummary.d0A <- DataFrame(LibSize = sum(qc.lib.d0A),
                               NExprs = sum(qc.nexprs.d0A),
                               MitoProp = sum(qc.mito.d0A),
                               Total = sum(discard.d0A))
discardSummary.d0B <- DataFrame(LibSize = sum(qc.lib.d0B),
                               NExprs = sum(qc.nexprs.d0B),
                               MitoProp = sum(qc.mito.d0B),
                               Total = sum(discard.d0B))
discardSummary.d0C <- DataFrame(LibSize = sum(qc.lib.d0C),
                               NExprs = sum(qc.nexprs.d0C),
                               MitoProp = sum(qc.mito.d0C),
                               Total = sum(discard.d0C))

discardSummary.d5A <- DataFrame(LibSize = sum(qc.lib.d5A),
                               NExprs = sum(qc.nexprs.d5A),
                               MitoProp = sum(qc.mito.d5A),
                               Total = sum(discard.d5A))
discardSummary.d5B <- DataFrame(LibSize = sum(qc.lib.d5B),
                               NExprs = sum(qc.nexprs.d5B),
                               MitoProp = sum(qc.mito.d5B),
                               Total = sum(discard.d5B))
discardSummary.d5C <- DataFrame(LibSize = sum(qc.lib.d5C),
                               NExprs = sum(qc.nexprs.d5C),
                               MitoProp = sum(qc.mito.d5C),
                               Total = sum(discard.d5C))

discardSummary.d7C <- DataFrame(LibSize = sum(qc.lib.d7C),
                               NExprs = sum(qc.nexprs.d7C),
                               MitoProp = sum(qc.mito.d7C),
                               Total = sum(discard.d7C))
discardSummary.d7D <- DataFrame(LibSize = sum(qc.lib.d7D),
                               NExprs = sum(qc.nexprs.d7D),
                               MitoProp = sum(qc.mito.d7D),
                               Total = sum(discard.d7D))

discardSummary.d0A
discardSummary.d0B
discardSummary.d0C
discardSummary.d5A
discardSummary.d5B
discardSummary.d5C
discardSummary.d7C
discardSummary.d7D

all_discards <- c(discard.d0A, discard.d0B, discard.d0C, discard.d5A, discard.d5B, discard.d5C, discard.d7C, discard.d7D)
sce.deMicheli$discard <- all_discards

# Check cell types of discarded
table(sce.deMicheli[, sce.deMicheli$discard == TRUE]$cell_annotation)
table(sce.deMicheli$cell_annotation)

# Filter outliers
sce.deMicheli.f <- sce.deMicheli[, sce.deMicheli$discard == FALSE]

# Save filtered sce file
#saveRDS(sce.deMicheli.f, file = "./../saved/R_objects/sce_deMicheli_f")
```

**Plot QC figures**
```{r deMicheli-qc-plots}
# Plot Quality control metrics
gridExtra::grid.arrange(
  plotColData(sce.deMicheli, x = "sampleID", y = "sum", colour_by = "discard", point_size = 0.3) +
    scale_y_log10() +
    ggtitle("Total counts") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x = "sampleID", y = "detected", colour_by = "discard", point_size = 0.3) +
    scale_y_log10() +
    ggtitle("Detected genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x = "sampleID", y = "subsets_Mito_percent", colour_by = "discard", point_size = 0.3) +
    ggtitle("Percent mitochondrial reads") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.deMicheli, x="sampleID", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") + guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol = 1,
  top = "De Micheli et al. - QC metrics"
)

# Check for cell type enrichments in the discarded pool
lost <- calculateAverage(counts(sce.deMicheli)[, all_discards])
kept <- calculateAverage(counts(sce.deMicheli)[, !all_discards])

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)

plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "De Micheli et al.: logFC between discarded and kept cells")
points(abundance[rowData(sce.deMicheli)$mito==TRUE], logFC[rowData(sce.deMicheli)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce.deMicheli)[changed]
```


### 6.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-qc}
# Compute per cell quality control metrics
sce.dellOrso <- addPerCellQC(sce.dellOrso, subsets = list(Mito=grep("mt-", rownames(sce.dellOrso))))
rowData(sce.dellOrso)$mito <- FALSE
rowData(sce.dellOrso)$mito[grep("^mt-", rownames(sce.dellOrso))] <- TRUE

# Find outliers from total counts for each cell (sum)
qc.lib.hom1 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom1)
qc.lib.hom2 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom2)
qc.lib.inj1 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj1)
qc.lib.inj2 <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj2)
qc.lib.pmb <- isOutlier(sce.dellOrso$sum[sce.dellOrso$sample == "Primary_MB"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.pmb)

#Find outliers from total number of detected genes
qc.nexprs.hom1 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom1)
qc.nexprs.hom2 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.hom2)
qc.nexprs.inj1 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj1)
qc.nexprs.inj2 <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.inj2)
qc.nexprs.pmb <- isOutlier(sce.dellOrso$detected[sce.dellOrso$sample == "Primary_MB"], log = TRUE, type = "both", nmads = 3)
summary(qc.lib.pmb)

# Find outliers from percentage of reads mapped to mitochondrial transcripts
qc.mito.hom1 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "homeostatic_MuSCs_rep1"] > 20
summary(qc.mito.hom1)
qc.mito.hom2 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "homeostatic_MuSCs_rep2"] > 20
summary(qc.mito.hom2)
qc.mito.inj1 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "inj_60h_MuSCs_rep1"] > 20
summary(qc.mito.inj1)
qc.mito.inj2 <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "inj_60h_MuSCs_rep2"] > 20
summary(qc.mito.inj2)
qc.mito.pmb <- sce.dellOrso$subsets_Mito_percent[sce.dellOrso$sample == "Primary_MB"] > 20
summary(qc.lib.pmb)

# Check if QC metrics correlate
cdf.dellOrso <- colData(sce.dellOrso)[c("subsets_Mito_percent","sum","detected")]
cors.dellOrso <- cor(as.matrix(cdf.dellOrso))
cors.dellOrso

# Combine discards
discard.hom1 <- qc.lib.hom1 | qc.nexprs.hom1 | qc.mito.hom1
discard.hom2 <- qc.lib.hom2 | qc.nexprs.hom2 | qc.mito.hom2
discard.inj1 <- qc.lib.inj1 | qc.nexprs.inj1 | qc.mito.inj1
discard.inj2 <- qc.lib.inj2 | qc.nexprs.inj2 | qc.mito.inj2
discard.pmb <- qc.lib.pmb | qc.nexprs.pmb | qc.mito.pmb

# Summarize the number of cells removed for each reason
discardSummary.hom1 <- DataFrame(LibSize = sum(qc.lib.hom1),
                               NExprs = sum(qc.nexprs.hom1),
                               MitoProp = sum(qc.mito.hom1),
                               Total = sum(discard.hom1))
discardSummary.hom2 <- DataFrame(LibSize = sum(qc.lib.hom2),
                                 NExprs = sum(qc.nexprs.hom2),
                                 MitoProp = sum(qc.mito.hom2),
                                 Total = sum(discard.hom2))
discardSummary.inj1 <- DataFrame(LibSize = sum(qc.lib.inj1),
                                 NExprs = sum(qc.nexprs.inj1),
                                 MitoProp = sum(qc.mito.inj1),
                                 Total = sum(discard.inj1))
discardSummary.inj2 <- DataFrame(LibSize = sum(qc.lib.inj2),
                                 NExprs = sum(qc.nexprs.inj2),
                                 MitoProp = sum(qc.mito.inj2),
                                 Total = sum(discard.inj2))
discardSummary.pmb <- DataFrame(LibSize = sum(qc.lib.pmb),
                                 NExprs = sum(qc.nexprs.pmb),
                                 MitoProp = sum(qc.mito.pmb),
                                 Total = sum(discard.pmb))

discardSummary.hom1
discardSummary.hom2
discardSummary.inj1
discardSummary.inj2
discardSummary.pmb

sce.dellOrso$discard <- c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)

# Filter outliers
sce.dellOrso.f <- sce.dellOrso[, sce.dellOrso$discard == FALSE]

# Save filtered sce file
#saveRDS(sce.dellOrso.f, file = "./../saved/R_objects/sce_dellOrso_f")
```

**Plot QC figures**
```{r dellOrso-qc-plots}
# Plot QC metrics
gridExtra::grid.arrange(
  plotColData(sce.dellOrso, x="sample", y="sum",colour_by = "discard",point_size=0.3) +
    scale_y_log10() + 
    ggtitle("Total counts") + 
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="detected",colour_by = "discard",point_size=0.3) + 
    scale_y_log10() +
    ggtitle("Detected genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="subsets_Mito_percent",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent mitochondrial reads") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  plotColData(sce.dellOrso, x="sample", y="percent_top_500",colour_by = "discard",point_size=0.3) + 
    ggtitle("Percent top 500 genes") +
    guides(colour = guide_legend(override.aes = list(size=15, alpha = 1))),
  ncol=1,
  top = "Dell'Orso et al.: QC metrics"
)

# Check for cell type enrichment in the discarded pool
lost <- calculateAverage(counts(sce.dellOrso)[,c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)])
kept <- calculateAverage(counts(sce.dellOrso)[,!c(discard.hom1, discard.hom2, discard.inj1, discard.inj2, discard.pmb)])

logged <- cpm(cbind(lost, kept), log=TRUE, prior.count=2)
logFC <- logged[,1] - logged[,2]
abundance <- rowMeans(logged)

# Plot gene logFC between discarded and kept cells (blue = mitochondrial genes)
plot(abundance, logFC, xlab="Average count", ylab="Log-FC (lost/kept)", pch=16, main = "Dell'Orso et al.: logFC between discarded and kept cells")
points(abundance[rowData(sce.dellOrso)$mito==TRUE], logFC[rowData(sce.dellOrso)$mito==TRUE], col="dodgerblue", pch=16)

changed <- logFC > 1

# Up in discarded
rownames(sce.dellOrso)[changed]
```

**Remove raw sce objects**
```{r remove-raw-sce-objects}
remove(sce)
remove(sce.deMicheli)
remove(sce.dellOrso)
```


## 7. Normalization
We perform normalization here to address for the systematic differences in sequence coverage between libraries.
We aim to remove these technical differences such that they don't interfere with comparisons of the expression profiles between cells.

Here we:
  - Perform scaling normalization by dividing all counts for each cell by a cell-specific scaling factor, also known as "size factor"
  - The size factor for each cell represents the estimate of the relative bias in that cell, so division of its counts by its size factor should remove that bias
  - Once size factors are computed, we use logNormCounts() to compute normalized exp. values for each cell

**Load normalized sce objects**
```{r shortcut-load-normalized-sce-files}
# Normalized sce objects
sce.n <- readRDS("./../saved/R_objects/sce_n")
sce.deMicheli.n <- readRDS("./../saved/R_objects/sce_deMicheli_n")
sce.dellOrso.n <- readRDS("./../saved/R_objects/sce_dellOrso_n")
```

### 7.1 Primary data
```{r primary-data-normalization, eval=FALSE}
# Compute size factors
sce.n <- sce.f
lib.sf <- librarySizeFactors(sce.n)
summary(lib.sf)

set.seed(100)
quickie <- quickCluster(sce.n,block=sce.n$sample)
table(quickie)

sce.n <- computeSumFactors(sce.n, cluster=quickie)

deconv.sf <- sizeFactors(sce.n)

# Compute log-normalized expression values for each cell
sce.n <- logNormCounts(sce.n)

# Save normalized data
saveRDS(sce.n, file = "./../saved/R_objects/sce_n")

```

**Normalization plots**
```{r primary-data-normalization-plots}
# Plot library size factor vs. deconvolution size factor
lib.sf <- librarySizeFactors(sce.n)
deconv.sf <- sizeFactors(sce.n)
plot(lib.sf, deconv.sf, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16, main = "Primary data: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")
```



### 7.2 De Micheli et al. (2020) reference data
```{r deMicheli-normalization, eval=FALSE}
# Compute size factors
sce.deMicheli.n <- sce.deMicheli.f
lib.sf.deMicheli <- librarySizeFactors(sce.deMicheli.n)
summary(lib.sf.deMicheli)

set.seed(100)
clust.deMicheli <- quickCluster(sce.deMicheli.n)

sce.deMicheli.n <- computeSumFactors(sce.deMicheli.n,
                                     cluster = clust.deMicheli,
                                     min.mean = 0.1)

deconv.sf.deMicheli <- sizeFactors(sce.deMicheli.n)
summary(deconv.sf.deMicheli)

# Compute log-normalized expression values for each cell
sce.deMicheli.n <- logNormCounts(sce.deMicheli.n)

# Save normalized data
saveRDS(sce.deMicheli.n, file = "./../saved/R_objects/sce_deMicheli_n")
```

**Normalization plots**
```{r deMicheli-normalization-plots}
# Plot library size factors vs. deconvolution size factor
lib.sf.deMicheli <- librarySizeFactors(sce.deMicheli.n)
deconv.sf.deMicheli <- sizeFactors(sce.deMicheli.n)
plot(lib.sf.deMicheli, deconv.sf.deMicheli, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16, main = "De Micheli et al.: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")

```



### 7.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-normalization, eval=FALSE}
# Compute size factors
sce.dellOrso.n <- sce.dellOrso.f
lib.sf.dellOrso <- librarySizeFactors(sce.dellOrso.n)
summary(lib.sf.dellOrso)

set.seed(100)
clust.dellOrso <- quickCluster(sce.dellOrso.n)

sce.dellOrso.n <- computeSumFactors(sce.dellOrso.n,
                                    cluster = clust.dellOrso,
                                    min.mean = 0.1)

deconv.sf.dellOrso <- sizeFactors(sce.dellOrso.n)
summary(deconv.sf.dellOrso)

# Compute log-normalized expression values for each cell
sce.dellOrso.n <- logNormCounts(sce.dellOrso.n)

# Save normalized data
saveRDS(sce.dellOrso.n, file = "./../saved/R_objects/sce_dellOrso_n")
```

**Normalization plots**
```{r dellOrso-normalization-plots}
# Plot library size factor vs. deconvolution size factor
lib.sf.dellOrso <- librarySizeFactors(sce.dellOrso.n)
deconv.sf.dellOrso <- sizeFactors(sce.dellOrso.n)
plot(lib.sf.dellOrso, deconv.sf.dellOrso, xlab="Library size factor",
     ylab="Deconvolution size factor", log='xy', pch=16,  main = "Dell'Orso et al.: library size factor vs. deconvolution size factor")
abline(a=0, b=1, col="red")
```

**Remove QC sce objects**
```{r remove-qc-sce-objects}
remove(sce.f)
remove(sce.deMicheli.f)
remove(sce.dellOrso.f)
```


## 8. Variance modelling
The simplest approach to quantifying per-gene variation is to simply compute the variance of the log-normalized expression values (log counts)
  - We use the modelGeneVar() function to fit a trend to the variance with respect to abundance across all genes
  - Once we have quantified the per-gene variation, the next step is to select the subset of HVGs to use in downstream analyses.
  - Here we select top 10% of the genes with the largest values for relevant variance metric

**Load feature selection objects**
```{r shortcut-load-feature-selection-objects}
# Feature selection objects
hvgs.data <- readRDS("./../saved/R_objects/hvgs_data")
dec.data <- readRDS("./../saved/R_objects/dec_data")
hvgs.deMicheli <- readRDS("./../saved/R_objects/hvgs_deMicheli")
dec.deMicheli <- readRDS("./../saved/R_objects/dec_deMicheli")
hvgs.dellOrso <- readRDS("./../saved/R_objects/hvgs_dellOrso")
dec.dellOrso <- readRDS("./../saved/R_objects/dec_dellOrso")
```


### 8.1 Primary data
```{r primary-data-feature-selection, eval=FALSE}
# Model per-gene variance
dec.data <- modelGeneVar(sce.n)

# Define highly variable genes (HVGs)
hvgs.data <- getTopHVGs(dec.data, prop = 0.1)

# save HVGS and per-gene variance
saveRDS(hvgs.data, file = "./../saved/R_objects/hvgs_data")
saveRDS(dec.data, file = "./../saved/R_objects/dec_data")
```

**Feature selection plots**
```{r primary-data-feature-selection-plot}
# Visualizing the fit
fit1 <- metadata(dec.data)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression",
     ylab = "Variance of log-expression", main = "Primary data: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```



### 8.2 De Micheli et al. (2020) reference data
```{r deMicheli-feature-selection, eval=FALSE}
# Model per-gene variance (technical & biological variation)
dec.deMicheli <- modelGeneVar(sce.deMicheli.n)

#Visualize the fit
fit1 <- metadata(dec.deMicheli)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "De Micheli et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# Define the highly variable genes (HVGs)
hvgs.deMicheli <- getTopHVGs(dec.deMicheli, prop = 0.1)

# save HVGS and per-gene variance
saveRDS(hvgs.deMicheli, file = "./../saved/R_objects/hvgs_deMicheli")
saveRDS(dec.deMicheli, file = "./../saved/R_objects/dec_deMicheli")
```

**Feature selection plots**
```{r deMicheli-feature-selection-plot}
#Visualize the fit
fit1 <- metadata(dec.deMicheli)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "De Micheli et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```


### 8.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-feature-selection, eval=FALSE}
# Model per-gene variance (technical & biological variation)
dec.dellOrso <- modelGeneVar(sce.dellOrso.n)

#Visualize the fit
fit1 <- metadata(dec.dellOrso)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "Dell'Orso et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

# Define the highly variable genes (HVGs)
hvgs.dellOrso <- getTopHVGs(dec.dellOrso, prop = 0.1)

# save HVGS and per-gene variance
saveRDS(hvgs.dellOrso, file = "./../saved/R_objects/hvgs_dellOrso")
saveRDS(dec.dellOrso, file = "./../saved/R_objects/dec_dellOrso")
```


**Feature selection plots**
```{r dellOrso-feature-selection-plot}
#Visualize the fit
fit1 <- metadata(dec.dellOrso)
plot(fit1$mean, fit1$var, xlab = "Mean of log-expression", ylab = "Variance of log-expression", main = "Dell'Orso et al.: variance vs. mean of log-expression")
curve(fit1$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)
```



## 9. Diagnosing batch effects
Here we inspect whether replicate samples in the Dell'Orso dataset cluster together or if they create separate clusters, in which case there would be a batch effect present in the data.

### 8.2 De Micheli et al. (2020) reference data
```{r deMicheli-batch-effects}
# full data
set.seed(123)
uncorrected.deMicheli <- runPCA(sce.deMicheli.n, subset_row = hvgs.deMicheli, BSPARAM = BiocSingular::RandomParam())
snn.gr.deMicheli <- buildSNNGraph(uncorrected.deMicheli, use.dimred = "PCA")
clusters.deMicheli <- igraph::cluster_walktrap(snn.gr.deMicheli)$membership
tab <- table(Cluster = clusters.deMicheli, Batch = uncorrected.deMicheli$sampleID)

set.seed(123)
uncorrected.deMicheli <- runTSNE(uncorrected.deMicheli, dimred = "PCA")
plotTSNE(uncorrected.deMicheli, colour_by = "sampleID") + ggtitle("All samples") 

# Plot samples (d0, d5, d7 separately)
#d0
set.seed(123)
uncorrected.deMicheli.d0 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 0"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d0 <- buildSNNGraph(uncorrected.deMicheli.d0, use.dimred = "PCA")
clusters.deMicheli.d0 <- igraph::cluster_walktrap(snn.gr.deMicheli.d0)$membership
tab.d0 <- table(Cluster = clusters.deMicheli.d0, Batch = uncorrected.deMicheli.d0$sampleID)

set.seed(123)
uncorrected.deMicheli.d0 <- runTSNE(uncorrected.deMicheli.d0, dimred = "PCA")

#d5
set.seed(123)
uncorrected.deMicheli.d5 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 5"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d5 <- buildSNNGraph(uncorrected.deMicheli.d5, use.dimred = "PCA")
clusters.deMicheli.d5 <- igraph::cluster_walktrap(snn.gr.deMicheli.d5)$membership
tab.d5 <- table(Cluster = clusters.deMicheli.d5, Batch = uncorrected.deMicheli.d5$sampleID)

set.seed(123)
uncorrected.deMicheli.d5 <- runTSNE(uncorrected.deMicheli.d5, dimred = "PCA")

#d7
set.seed(123)
uncorrected.deMicheli.d7 <- runPCA(sce.deMicheli.n[, sce.deMicheli.n$injury == "Day 7"],
                                   subset_row = hvgs.deMicheli,
                                   BSPARAM = BiocSingular::RandomParam())

snn.gr.deMicheli.d7 <- buildSNNGraph(uncorrected.deMicheli.d7, use.dimred = "PCA")
clusters.deMicheli.d7 <- igraph::cluster_walktrap(snn.gr.deMicheli.d7)$membership
tab.d7 <- table(Cluster = clusters.deMicheli.d7, Batch = uncorrected.deMicheli.d7$sampleID)

set.seed(123)
uncorrected.deMicheli.d7 <- runTSNE(uncorrected.deMicheli.d7, dimred = "PCA")

# plots
p.d0 <- plotTSNE(uncorrected.deMicheli.d0, colour_by = "sampleID") + ggtitle("Day 0") 
p.d0b <- plotTSNE(uncorrected.deMicheli.d0, colour_by = "cell_annotation") + ggtitle("Day 0") 
p.d5 <- plotTSNE(uncorrected.deMicheli.d5, colour_by = "sampleID") + ggtitle("Day 5")
p.d5b <- plotTSNE(uncorrected.deMicheli.d5, colour_by = "cell_annotation") + ggtitle("Day 5")
p.d7 <- plotTSNE(uncorrected.deMicheli.d7, colour_by = "sampleID") + ggtitle("Day 7") 
p.d7b <- plotTSNE(uncorrected.deMicheli.d7, colour_by = "cell_annotation") + ggtitle("Day 7") 
gridExtra::grid.arrange(p.d0, p.d0b, p.d5, p.d5b, p.d7, p.d7b,
                        top = "De Micheli et al.: TSNE plots to diagnose batch effects")

```
 
**Conclusions:**

 - As can be seen, the replicate samples seem not to create separate clusters, except for Day 7 samples
 - The clusters seem to separate mostly by the cell types
 - In the Day 7 sample, the samples seem to create separate clusters. This was mentioned in the article as well but they decided to leave it uncorrected.


### 9.1 Dell'Orso et al. (2019) reference data
```{r dellOrso-batch-effects}
set.seed(123)
uncorrected.dellOrso <- runPCA(sce.dellOrso.n, subset_row = hvgs.dellOrso,
                                BSPARAM = BiocSingular::RandomParam())

snn.gr.dellOrso <- buildSNNGraph(uncorrected.dellOrso, use.dimred = "PCA")
clusters.dellOrso <- igraph::cluster_walktrap(snn.gr.dellOrso)$membership

tab <- table(Cluster = clusters.dellOrso, Batch = uncorrected.dellOrso$sample)
tab

set.seed(123)
uncorrected.dellOrso <- runTSNE(uncorrected.dellOrso, dimred = "PCA")
plotTSNE(uncorrected.dellOrso, colour_by = "sample") + ggtitle("Dell'Orso et al.: TSNE plot to diagnose batch effects")
```
  
**Conclusions:**
  - The replicate clusters for inj_60h_MuSCs and homeostatic_MuSCs seem to cluster together, meaning that these replicate samples contain similar gene expression data and thus no batch correction is required.


## 10. Cell cycle scoring and regression
Cell cycle scoring and regression is performed to inspect if the cell cycle phases affect the gene expression of cells and if this is the case, then this type of variability in the data is regressed out.

  - Here, we assign each cell a score, based on its expression of G2/M and S phase markers. Cells expressing neither are likely in G1 phase
  - Then, we subtract (regress out) this source of heterogeneity from the data.

We use two different methods for performing cell cycle correction. First, following a Seurat cell cycle correction (https://satijalab.org/seurat/v3.2/cell_cycle_vignette.html) and then, following a Bioconductor approach (https://osca.bioconductor.org/cell-cycle-assignment.html)

**Load cell cycle correction objects**
```{r load-cc-objects}
# Cell cycle correction
g2m.genes.mouse <- readRDS("./../saved/R_objects/g2m_genes_mouse")
s.genes.mouse <- readRDS("./../saved/R_objects/s_genes_mouse")
sce.cc <- readRDS("./../saved/R_objects/sce_cc")
sce.deMicheli.cc <- readRDS("./../saved/R_objects/sce_deMicheli_cc")
sce.dellOrso.cc <- readRDS("./../saved/R_objects/sce_dellOrso_cc")
```


### 10.1 Prepare cell cycle markers and transform from human to mouse genes
```{r cell-cycle-markers, eval=FALSE}
# Make mapping between human and mouse genes
ensembl.human <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl.mouse <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

mouse_to_human_genes <- getLDS(attributes = c('external_gene_name'),
                               filters = 'external_gene_name',
                               values = c(rownames(sce.n), rownames(sce.deMicheli.n), rownames(sce.dellOrso.n)),
                               mart = ensembl.mouse,
                               attributesL = c('external_gene_name'),
                               martL = ensembl.human)

names(mouse_to_human_genes) <- c("mouse", "human")

# Get a list of cell cycle markers (G2/M phase and S phase markers)
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Convert cell cycle markers from human genes to mouse genes
g2m.genes.mouse <- c()
s.genes.mouse <- c()

for(g in s.genes) {
  gene <- mouse_to_human_genes[mouse_to_human_genes$human == g, ]$mouse
  if(length(gene) > 0) {
    s.genes.mouse <- append(s.genes.mouse, gene)
  }
}

for(g in g2m.genes) {
  gene <- mouse_to_human_genes[mouse_to_human_genes$human == g, ]$mouse
  if(length(gene) > 0) {
    g2m.genes.mouse <- append(g2m.genes.mouse, gene)
  }
}

# Save mouse cell cycle phase gene objects
saveRDS(g2m.genes.mouse, file = "./../saved/R_objects/g2m_genes_mouse")
saveRDS(s.genes.mouse, file = "./../saved/R_objects/s_genes_mouse")
```



### 10.2 Primary data (Seurat cell cycle correction)
```{r primary-data-cc, eval=FALSE}
# Convert sce into Seurat object
data <- as.Seurat(sce.n, counts = "counts", data = "logcounts")

# Perform Seurat normalization
data <- NormalizeData(data)

# Add normalized values from sce object to the Seurat object
data@assays$RNA@data <- logcounts(sce.n)

# Assign cell cycle scores
data <- CellCycleScoring(data, s.features = s.genes.mouse, g2m.features = g2m.genes.mouse, set.ident = TRUE)

# Visualize the distribution of cell cycle markers across
RidgePlot(data, features = c("Pcna", "Top2a", "Mcm6", "Mki67"), ncol = 2)

# Calculate the difference between the G2M and S phase scores
data$CC.Difference <- data$S.Score - data$G2M.Score

# Find variable features
data <- FindVariableFeatures(data, selection.method = "vst")

# Set HVGs from the sce object into the Seurat object's variable features
data@assays$RNA@var.features <- hvgs.data

# Regress out CC difference using the HVGs as features
data <- ScaleData(data, vars.to.regress = "CC.Difference", features = VariableFeatures(data))

# Run PCA on HVGs and cell cycle genes
set.seed(123)
data <- RunPCA(data, features = VariableFeatures(data), nfeatures.print = 10)
DimPlot(data)

set.seed(123)
data <- RunPCA(data, features = c(s.genes.mouse, g2m.genes.mouse), BSPARAM = BiocSingular::RandomParam())
DimPlot(data)

# Transform back to sce object
sce.cc <- as.SingleCellExperiment(data, assay = "RNA")

# Set the CC corrected data into the sce object as an alternative experiment
cc_corrected <- SummarizedExperiment(assays = list(scaled_logcounts = data@assays$RNA@scale.data),
                                     colData = colData(sce.cc))

altExp(sce.cc, "CC_corrected", withColData = TRUE) <- cc_corrected

# save sce object
saveRDS(sce.cc, file = "./../saved/R_objects/sce_cc")
```

**Cell cycle regression plots**
```{r primary-data-cc-plots}
# Plot cell cycle phases for each sample as pie charts
cc_vs_labels <- as.data.frame.matrix(table(altExp(sce.cc, "CC_corrected")$Phase, altExp(sce.cc, "CC_corrected")$sample))

par(mfrow=c(2,3))
pie(cc_vs_labels$control, labels = rownames(cc_vs_labels), main = "Control")
pie(cc_vs_labels$cap50, labels = rownames(cc_vs_labels), main = "Cap50")
pie(cc_vs_labels$cap50_r4h, labels = rownames(cc_vs_labels), main = "Cap50_r4h")
pie(cc_vs_labels$cap50_r8h, labels = rownames(cc_vs_labels), main = "Cap50_r8h")
pie(cc_vs_labels$cap50_r16h, labels = rownames(cc_vs_labels), main = "Cap50_r16h")

# Merge G2M and S-phase into "dividing" and make a new Phase2 variable based on this
sce.cc$Phase2 <- ifelse(sce.cc$Phase == "G1", "non-dividing", "dividing")

par(mfrow=c(1,1))
ggplot(data = as.data.frame(colData(sce.cc)), mapping = aes(x = factor(sample, levels = c("control", "cap50", "cap50_r4h", "cap50_r8h", "cap50_r16h")), fill = as.factor(Phase2))) +
  geom_bar(position = "dodge") +
  labs(x = "Sample", y = "Number of cells", fill = "Cell cycle phase")

# Fisher's exact test to inspect differences in cell cycle stages between groups
cont.tab <- table(sce.cc$Phase2, sce.cc$sample)
cont.tab <- cont.tab[, c("control", "cap50", "cap50_r4h", "cap50_r8h", "cap50_r16h")]

results = data.frame(t(combn(colnames(cont.tab),2)), stringsAsFactors = F)
results$p.value <- 0

for(i in 1:dim(results)[1]) {
  X1 <- results[i, 1]
  X2 <- results[i, 2]
  cont.tab.f <- cont.tab[, c(X1, X2)]
  
  # Calculate p-value for each pair 10 times
  res <- 0
  for(j in 1:100) {
    fish <- fisher.test(cont.tab.f)$p.value
    res <- sum(res, fish)
  }
  results[i, ]$p.value <- res/100
}

results$signifant <- ifelse(results$p.value < 0.05, TRUE, FALSE)
results

# Plot PCA and UMAP plots before and after regressing out the cell cycle effect
sce.cc.uncorrected <- sce.cc
sce.cc.corrected <- as(altExp(sce.cc, "CC_corrected"), "SingleCellExperiment")

set.seed(123)
sce.cc.uncorrected <- runPCA(sce.cc.uncorrected, exprs_values = "logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse))
set.seed(123)
sce.cc.corrected <- runPCA(sce.cc.corrected, exprs_values = "scaled_logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse)[c(s.genes.mouse, g2m.genes.mouse) %in% rownames(sce.cc.corrected)])

pca.uncorrected <- plotReducedDim(sce.cc.uncorrected, dimred = "PCA", colour_by = "Phase") + ggtitle("Uncorrected dataset: PCA plot")
pca.corrected <- plotReducedDim(sce.cc.corrected, dimred = "PCA", colour_by = "Phase") + ggtitle("CC corrected dataset: PCA plot")

gridExtra::grid.arrange(pca.corrected, pca.uncorrected, ncol = 2)

set.seed(123)
sce.cc.uncorrected <- runUMAP(sce.cc.uncorrected, exprs_values = "logcounts", dimred = "PCA")
set.seed(123)
sce.cc.corrected <- runUMAP(sce.cc.corrected, exprs_values = "scaled_logcounts", dimred = "PCA")
umap.uncorrected <- plotUMAP(sce.cc.uncorrected, colour_by = "Phase") + ggtitle("Uncorrected dataset: UMAP plot")
umap.corrected <- plotUMAP(sce.cc.corrected, colour_by = "Phase") + ggtitle("CC corrected dataset: UMAP plot")

gridExtra::grid.arrange(umap.uncorrected, umap.corrected, ncol = 2)
```




### 10.3 Reference datasets
#### 10.3.1 Add cell annotations to reference datasets
```{r reference-data-cell-annotations}
# De Micheli et al.
d0_muscle <- sce.deMicheli.n$injury == "Day 0" & sce.deMicheli.n$cell_annotation == "Mature skeletal muscle"
d0_musc <- sce.deMicheli.n$injury == "Day 0" & sce.deMicheli.n$cell_annotation == "MuSCs and progenitors"
d5_muscle <- sce.deMicheli.n$injury == "Day 5" & sce.deMicheli.n$cell_annotation == "Mature skeletal muscle"
d5_musc <- sce.deMicheli.n$injury == "Day 5" & sce.deMicheli.n$cell_annotation == "MuSCs and progenitors"
d7_muscle <- sce.deMicheli.n$injury == "Day 7" & sce.deMicheli.n$cell_annotation == "Mature skeletal muscle"
d7_musc <- sce.deMicheli.n$injury == "Day 7" & sce.deMicheli.n$cell_annotation == "MuSCs and progenitors"

sce.deMicheli.n$cell_type[d0_musc] <- "d0_MuSCs_and_progenitors"
sce.deMicheli.n$cell_type[d5_musc] <- "d5_MuSCs_and_progenitors"
sce.deMicheli.n$cell_type[d7_musc] <- "d7_MuSCs_and_progenitors"
sce.deMicheli.n$cell_type[d0_muscle] <- "d0_mature_skeletal_muscle"
sce.deMicheli.n$cell_type[d5_muscle] <- "d5_mature_skeletal_muscle"
sce.deMicheli.n$cell_type[d7_muscle] <- "d7_mature_skeletal_muscle"

# Dell Orso et al.
hom1 <- sce.dellOrso.n$sample == "homeostatic_MuSCs_rep1"
hom2 <- sce.dellOrso.n$sample == "homeostatic_MuSCs_rep2"
inj1 <- sce.dellOrso.n$sample == "inj_60h_MuSCs_rep1"
inj2 <- sce.dellOrso.n$sample == "inj_60h_MuSCs_rep2"
pmb <- sce.dellOrso.n$sample == "Primary_MB"
  
sce.dellOrso.n$cell_type[hom1] <- "homeostatic_MuSCs" 
sce.dellOrso.n$cell_type[hom2] <- "homeostatic_MuSCs" 
sce.dellOrso.n$cell_type[inj1] <- "inj_60h_MuSCs" 
sce.dellOrso.n$cell_type[inj2] <- "inj_60h_MuSCs" 
sce.dellOrso.n$cell_type[pmb] <- "Primary_MB"
```


#### 10.3.2 Cell cycle annotation & correction for reference datasets
```{r ref-cellcycle-annotation, eval=FALSE}
# Convert sce objects into Seurat objects
deMicheli.seurat <- as.Seurat(sce.deMicheli.n, counts = "counts", data = "logcounts")
dellOrso.seurat <- as.Seurat(sce.dellOrso.n, counts = "counts", data = "logcounts")

# Perform Seurat normalization and update normalized values from sce objects
deMicheli.seurat <- NormalizeData(deMicheli.seurat)
dellOrso.seurat <- NormalizeData(dellOrso.seurat)
deMicheli.seurat@assays$RNA@data <- logcounts(sce.deMicheli.n)
dellOrso.seurat@assays$RNA@data <- logcounts(sce.dellOrso.n)

# Assign cell cycle scores
deMicheli.seurat <- CellCycleScoring(deMicheli.seurat, s.features = s.genes.mouse, g2m.features = g2m.genes.mouse, set.ident = TRUE)
dellOrso.seurat <- CellCycleScoring(dellOrso.seurat, s.features = s.genes.mouse, g2m.features = g2m.genes.mouse, set.ident = TRUE)

# Visualize the distribution of cell cycle marker genes
RidgePlot(deMicheli.seurat, features = c("Pcna", "Top2a", "Mcm6", "Mki67"), ncol = 2)
RidgePlot(dellOrso.seurat, features = c("Pcna", "Top2a", "Mcm6", "Mki67"), ncol = 2)

# Caluclate the CC differences
deMicheli.seurat$CC.Difference <- deMicheli.seurat$S.Score - deMicheli.seurat$G2M.Score
dellOrso.seurat$CC.Difference <- dellOrso.seurat$S.Score - dellOrso.seurat$G2M.Score

# Find variable features and set HVGs from original sce object as variable features in the seurat object
deMicheli.seurat <- FindVariableFeatures(deMicheli.seurat, selection.method = "vst")
dellOrso.seurat <- FindVariableFeatures(dellOrso.seurat, selection.method = "vst")
deMicheli.seurat@assays$RNA@var.features <- hvgs.deMicheli
dellOrso.seurat@assays$RNA@var.features <- hvgs.dellOrso

# Regress out CC difference using HVGs as features
deMicheli.seurat <- ScaleData(deMicheli.seurat, vars.to.regress = "CC.Difference", features = VariableFeatures(deMicheli.seurat))
dellOrso.seurat <- ScaleData(dellOrso.seurat, vars.to.regress = "CC.Difference", features = VariableFeatures(dellOrso.seurat))

# Convert back to sce objects
sce.deMicheli.cc <- as.SingleCellExperiment(deMicheli.seurat, assay = "RNA")
sce.dellOrso.cc <- as.SingleCellExperiment(dellOrso.seurat, assay = "RNA")

# Set scaled & centered expression values to the sce objects as alternative experiment
cc_corrected.deMicheli <- SummarizedExperiment(assays = list(scaled_logcounts = deMicheli.seurat@assays$RNA@scale.data),
                                               colData = colData(sce.deMicheli.cc))

cc_corrected.dellOrso <- SummarizedExperiment(assays = list(scaled_logcounts = dellOrso.seurat@assays$RNA@scale.data),
                                               colData = colData(sce.dellOrso.cc))

altExp(sce.deMicheli.cc, "CC_corrected", withColData = TRUE) <- cc_corrected.deMicheli
altExp(sce.dellOrso.cc, "CC_corrected", withColData = TRUE) <- cc_corrected.dellOrso

# Save cc objects
saveRDS(sce.deMicheli.cc, file = "./../saved/R_objects/sce_deMicheli_cc")
saveRDS(sce.dellOrso.cc, file = "./../saved/R_objects/sce_dellOrso_cc")
```

**Dimensionality reduction plots**
```{r ref-cellcycle-annotation-plots}
# Plot cc phases for the datasets
phases.deMicheli <- as.data.frame.matrix(table(sce.deMicheli.cc$Phase, sce.deMicheli.cc$cell_type))
phases.dellOrso <- as.data.frame.matrix(table(sce.dellOrso.cc$Phase, sce.dellOrso.cc$cell_type))

par(mfrow=c(3,3))
pie(phases.deMicheli$d0_mature_skeletal_muscle, labels = rownames(phases.deMicheli), main = "De Micheli: D0 mature skeletal muscle")
pie(phases.deMicheli$d5_mature_skeletal_muscle, labels = rownames(phases.deMicheli), main = "De Micheli: D5 mature skeletal muscle")
pie(phases.deMicheli$d7_mature_skeletal_muscle, labels = rownames(phases.deMicheli), main = "De Micheli: D7 mature skeletal muscle")
pie(phases.deMicheli$d0_MuSCs_and_progenitors, labels = rownames(phases.deMicheli), main = "De Micheli: D0 MuSCs and progenitors")
pie(phases.deMicheli$d5_MuSCs_and_progenitors, labels = rownames(phases.deMicheli), main = "De Micheli: D5 MuSCs and progenitors")
pie(phases.deMicheli$d7_MuSCs_and_progenitors, labels = rownames(phases.deMicheli), main = "De Micheli: D7 MuSCs and progenitors")
pie(phases.dellOrso$homeostatic_MuSCs, labels = rownames(phases.dellOrso), main = "Dell'Orso: homeostatic_MuSCs")
pie(phases.dellOrso$inj_60h_MuSCs, labels = rownames(phases.dellOrso), main = "Dell'Orso: inj_60h_MuSCs")
pie(phases.dellOrso$Primary_MB, labels = rownames(phases.dellOrso), main = "Dell'Orso: Primary_MB")


# De Micheli - plot PCA and UMAP plots before and after regressing out the cell cycle effect
sce.deMicheli.cc.uncorrected <- sce.deMicheli.cc
sce.deMicheli.cc.corrected <- as(altExp(sce.deMicheli.cc, "CC_corrected"), "SingleCellExperiment")

set.seed(123)
sce.deMicheli.cc.uncorrected <- runPCA(sce.deMicheli.cc.uncorrected, exprs_values = "logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse))
set.seed(123)
sce.deMicheli.cc.corrected <- runPCA(sce.deMicheli.cc.corrected, exprs_values = "scaled_logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse)[c(s.genes.mouse, g2m.genes.mouse) %in% rownames(sce.deMicheli.cc.corrected)])

pca.corrected.deMicheli <- plotReducedDim(sce.deMicheli.cc.corrected, dimred = "PCA", colour_by = "Phase") + ggtitle("CC corrected De Micheli dataset: PCA plot")
pca.uncorrected.deMicheli <- plotReducedDim(sce.deMicheli.cc.uncorrected, dimred = "PCA", colour_by = "Phase") + ggtitle("Uncorrected De Micheli dataset: PCA plot")
gridExtra::grid.arrange(pca.uncorrected.deMicheli, pca.corrected.deMicheli, ncol = 2)

set.seed(123)
sce.deMicheli.cc.uncorrected <- runUMAP(sce.deMicheli.cc.uncorrected, exprs_values = "logcounts", dimred = "PCA")
set.seed(123)
sce.deMicheli.cc.corrected <- runUMAP(sce.deMicheli.cc.corrected, exprs_values = "scaled_logcounts", dimred = "PCA")
umap.uncorrected.deMicheli <- plotUMAP(sce.deMicheli.cc.uncorrected, colour_by = "Phase") + ggtitle("Uncorrected  De Micheli dataset: UMAP plot")
umap.corrected.deMicheli <- plotUMAP(sce.deMicheli.cc.corrected, colour_by = "Phase") + ggtitle("CC corrected  De Micheli dataset: UMAP plot")
gridExtra::grid.arrange(umap.uncorrected.deMicheli, umap.corrected.deMicheli, ncol = 2)


# Dell'Orso - plot PCA and UMAP plots before and after regressing out the cell cycle effect
sce.dellOrso.cc.uncorrected <- sce.dellOrso.cc
sce.dellOrso.cc.corrected <- as(altExp(sce.dellOrso.cc, "CC_corrected"), "SingleCellExperiment")

set.seed(123)
sce.dellOrso.cc.uncorrected <- runPCA(sce.dellOrso.cc.uncorrected, exprs_values = "logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse))
set.seed(123)
sce.dellOrso.cc.corrected <- runPCA(sce.dellOrso.cc.corrected, exprs_values = "scaled_logcounts", subset_row = c(s.genes.mouse, g2m.genes.mouse)[c(s.genes.mouse, g2m.genes.mouse) %in% rownames(sce.dellOrso.cc.corrected)])

pca.corrected.dellOrso <- plotReducedDim(sce.dellOrso.cc.corrected, dimred = "PCA", colour_by = "Phase") + ggtitle("CC corrected Dell'Orso dataset: PCA plot")
pca.uncorrected.dellOrso <- plotReducedDim(sce.dellOrso.cc.uncorrected, dimred = "PCA", colour_by = "Phase") + ggtitle("Uncorrected Dell'Orso dataset: PCA plot")
gridExtra::grid.arrange(pca.corrected.dellOrso, pca.uncorrected.dellOrso, ncol = 2)

set.seed(123)
sce.dellOrso.cc.uncorrected <- runUMAP(sce.dellOrso.cc.uncorrected, exprs_values = "logcounts", dimred = "PCA")
set.seed(123)
sce.dellOrso.cc.corrected <- runUMAP(sce.dellOrso.cc.corrected, exprs_values = "scaled_logcounts", dimred = "PCA")
umap.uncorrected.dellOrso <- plotUMAP(sce.dellOrso.cc.uncorrected, colour_by = "Phase") + ggtitle("Uncorrected Dell'Orso dataset: UMAP plot")
umap.corrected.dellOrso <- plotUMAP(sce.dellOrso.cc.corrected, colour_by = "Phase") + ggtitle("CC corrected Dell'Orso dataset: UMAP plot")
gridExtra::grid.arrange(umap.uncorrected.dellOrso, umap.corrected.dellOrso, ncol = 2)
```

**Remove normalized sce objects**
```{r remove-normalized-sce-objects}
remove(sce.n)
remove(sce.deMicheli.n)
remove(sce.dellOrso.n)
```


## 11. Dimensionality reduction
  - PCA is performed on the log-normalized expression values by using runPCA() function
  - Remove PCs corresponding to technical noise

**load dimensionality reduction objects**
```{r shortcut-load-dimred-objects}
# Dimensionality reduction
denoised.sce <- readRDS("./../saved/R_objects/denoised_sce")
denoised.sce.deMicheli <-readRDS("./../saved/R_objects/denoised_sce_deMicheli")
denoised.sce.dellOrso <- readRDS("./../saved/R_objects/denoised_sce_dellOrso")
```


### 11.1 Primary data
```{r primary-data-dimension-reduction, eval=FALSE}
# PCA for non-corrected and cc-corrected data
set.seed(123)
sce.cc <- runPCA(sce.cc, subset_row = hvgs.data, exprs_values = "logcounts", name = "PCA")
set.seed(123)
sce.cc <- runPCA(sce.cc, altexp = "CC_corrected", subset_row = hvgs.data, exprs_values = "scaled_logcounts", name = "PCA_cc")

saveRDS(sce.cc, file = "./../saved/R_objects/sce_cc")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce <- denoisePCA(sce.cc, technical = dec.data, subset.row = hvgs.data, assay.type = "logcounts")
sce.cc.corrected <- denoisePCA(sce.cc.corrected, technical = dec.data, assay.type = "scaled_logcounts")
reducedDim(denoised.sce, "PCA_cc") <- reducedDim(sce.cc.corrected, "PCA")

# Save the sce object
saveRDS(denoised.sce, file = "./../saved/R_objects/denoised_sce")
```


**Dimensionality reduction plots**
```{r primary-data-dimension-reduction-plots}
# Plot reduced dims
plotReducedDim(sce.cc, dimred = "PCA", colour_by = "sample") + ggtitle("Primary data: PCA")
sce.cc.corrected <- as(altExp(sce.cc, "CC_corrected"), "SingleCellExperiment")
reducedDim(sce.cc.corrected, "PCA_cc") <- reducedDim(sce.cc, "PCA_cc")
plotReducedDim(sce.cc.corrected, dimred = "PCA_cc", colour_by = "sample") + ggtitle("Primary data (cc corrected): PCA")

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce, "PCA"))
ncol(reducedDim(denoised.sce, "PCA_cc"))
```


### 11.2 De Micheli et al. (2020) reference data
```{r deMicheli-dimension-reduction, eval=FALSE}
# PCA for non-corrected and cc-corrected data
set.seed(123)
sce.deMicheli.cc <- runPCA(sce.deMicheli.cc, subset_row = hvgs.deMicheli, exprs_values = "logcounts", name = "PCA")
set.seed(123)
sce.deMicheli.cc <- runPCA(sce.deMicheli.cc, altexp = "CC_corrected", subset_row = hvgs.deMicheli, exprs_values = "scaled_logcounts", name = "PCA_cc")

saveRDS(sce.deMicheli.cc, file = "./../saved/R_objects/sce_deMicheli_cc")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.deMicheli <- denoisePCA(sce.deMicheli.cc, technical = dec.deMicheli, subset.row = hvgs.deMicheli, assay.type = "logcounts")
sce.deMicheli.cc.corrected <- denoisePCA(sce.deMicheli.cc.corrected, technical = dec.deMicheli, assay.type = "scaled_logcounts")
reducedDim(denoised.sce.deMicheli, "PCA_cc") <- reducedDim(sce.deMicheli.cc.corrected, "PCA")

# Save sce object
saveRDS(denoised.sce.deMicheli, file = "./../saved/R_objects/denoised_sce_deMicheli")
```

**Dimensionality reduction plots**
```{r deMicheli-dimension-reduction-plots}
# Plot reduced dims
plotReducedDim(sce.deMicheli.cc, dimred = "PCA", colour_by = "cell_type")  + ggtitle("De Micheli data: PCA")
sce.deMicheli.cc.corrected <- as(altExp(sce.deMicheli.cc, "CC_corrected"), "SingleCellExperiment")
reducedDim(sce.deMicheli.cc.corrected, "PCA_cc") <- reducedDim(sce.deMicheli.cc, "PCA_cc")
plotReducedDim(sce.deMicheli.cc.corrected, dimred = "PCA_cc", colour_by = "cell_type") + ggtitle("De Micheli data (cc corrected): PCA")

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.deMicheli, "PCA"))
ncol(reducedDim(denoised.sce.deMicheli, "PCA_cc"))
```


### 11.3 Dell'Orso et al. (2019) reference data
```{r dellOrso-dimension-reduction, eval=FALSE}
# Perform dimension reduction
set.seed(123)
sce.dellOrso.cc <- runPCA(sce.dellOrso.cc, subset_row = hvgs.dellOrso,  exprs_values = "logcounts", name = "PCA")
set.seed(123)
sce.dellOrso.cc <- runPCA(sce.dellOrso.cc, altexp = "CC_corrected", subset_row = hvgs.dellOrso,  exprs_values = "scaled_logcounts", name = "PCA_cc")

saveRDS(sce.dellOrso.cc, file = "./../saved/R_objects/sce_dellOrso_cc")

# Remove PCs corresponding to technical noise
set.seed(123)
denoised.sce.dellOrso <- denoisePCA(sce.dellOrso.cc, technical = dec.dellOrso, subset.row = hvgs.dellOrso, assay.type = "logcounts")
sce.dellOrso.cc.corrected <- denoisePCA(sce.dellOrso.cc.corrected, technical = dec.dellOrso, assay.type = "scaled_logcounts")
reducedDim(denoised.sce.dellOrso, "PCA_cc") <- reducedDim(sce.dellOrso.cc.corrected, "PCA")

# Save sce object
saveRDS(denoised.sce.dellOrso, file = "./../saved/R_objects/denoised_sce_dellOrso")
```

**Dimensionality reduction plots**
```{r dellOrso-dimension-reduction-plots}
# Plot reduced dims
plotReducedDim(sce.dellOrso.cc, dimred = "PCA", colour_by = "cell_type")+ ggtitle("Dell'Orso data: PCA")
sce.dellOrso.cc.corrected <- as(altExp(sce.dellOrso.cc, "CC_corrected"), "SingleCellExperiment")
reducedDim(sce.dellOrso.cc.corrected, "PCA_cc") <- reducedDim(sce.dellOrso.cc, "PCA_cc")
plotReducedDim(sce.dellOrso.cc.corrected, dimred = "PCA_cc", colour_by = "cell_type") + ggtitle("Dell'Orso data (cc corrected): PCA")

# Dimensions of denoised PCA
ncol(reducedDim(denoised.sce.dellOrso, "PCA"))
ncol(reducedDim(denoised.sce.dellOrso, "PCA_cc"))
```



